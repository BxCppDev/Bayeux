/* bayeux/_init_fini.cc
 */
// Ourselves

// This package:
#include <datatools/datatools_config.h>
#include <datatools/library_info.h>
#include <datatools/properties.h>

#include <bayeux/version.h>
#include <datatools/version.h>
#include <cuts/version.h>
#include <materials/version.h>
#include <materials/resource.h>
#include <mygsl/version.h>
#include <geomtools/version.h>
#include <emfield/version.h>
#include <genbb_help/version.h>
#include <genvtx/version.h>
#include <trackfit/version.h>
#include <brio/version.h>
#include <dpp/version.h>

__attribute__((constructor))
static void bayeux_initializer()
{
  DT_LOG_TRACE(datatools::library_info::logging() == datatools::logger::PRIO_TRACE, "Entering...");
  static bool initialized = false;
  if (! initialized) {

    {
      datatools::properties & datatools_lib_infos
        = datatools::library_info::registration("datatools",
                                                "Serializable data structures based on Boost "
                                                "and general purpose utility classes and macros.",
                                                datatools::version::get_version()
                                                );
    }

    {
      datatools::properties & cuts_lib_infos
        = datatools::library_info::registration("cuts",
                                                "Generic tools for making arbitrary data selections.",
                                                cuts::version::get_version()
                                                );
    }

    {
      datatools::properties & materials_lib_infos
        = datatools::library_info::registration("materials",
                                                "Description of isotopes, elements and materials plus tools "
                                                "for input to simulation applications (i.e. GDML/Geant4).",
                                                materials::version::get_version()
                                                );
      materials_lib_infos.store_string(datatools::library_info::INSTALL_RESOURCE_DIR,
                                       materials::get_resource_dir(false));
    }

    {
      datatools::properties & mygsl_lib_infos
        = datatools::library_info::registration("mygsl",
                                                "C++ wrapper and extensions to the GNU Scientific Library.",
                                                mygsl::version::get_version(),
                                                "@CMAKE_INSTALL_PREFIX@"  // Hardcoded for now
                                                );
    }

    {
      datatools::properties & geomtools_lib_infos
        = datatools::library_info::registration("geomtools",
                                                "Generic tools for working with experiment geometries and "
                                                "provide input to simulation tools (i.e. GDML/Geant4).",
                                                geomtools::version::get_version()
                                                );
    }

    {
      datatools::properties & genvtx_lib_infos
        = datatools::library_info::registration("genvtx",
                                                "Vertex random generator tools for input to simulation applications.",
                                                genvtx::version::get_version()
                                                );
    }

    {
      datatools::properties & genbb_help_lib_infos
        = datatools::library_info::registration("genbb_help",
                                                "C++ port and extension to the Decay0/GENBB program by Vladimir Tretyak, "
                                                "for input to simulation applications.",
                                                genbb::version::get_version()
                                                );
    }

    {
      datatools::properties & emfield_lib_infos
        = datatools::library_info::registration("emfield",
                                                "Electromagnetic field modelling and management.",
                                                emfield::version::get_version()
                                                );
    }

    {
      datatools::properties & trackfit_lib_infos
        = datatools::library_info::registration("trackfit",
                                                "Track fitting in a NEMO-like detector.",
                                                trackfit::version::get_version()
                                                );
    }

    {
      datatools::properties & brio_lib_infos
        = datatools::library_info::registration("brio",
                                                "A Boost over ROOT I/O serialization system (extends datatools).",
                                                brio::version::get_version()
                                                );
    }

    {
      datatools::properties & dpp_lib_infos
        = datatools::library_info::registration("dpp",
                                                "A basic data processing pipeline API.",
                                                dpp::version::get_version()
                                                );
    }

    {
      datatools::properties & bayeux_lib_infos
        = datatools::library_info::registration("bayeux",
                                                "A C++ foundation library for small particle/nuclear physics experiments.",
                                                bayeux::version::get_version()
                                                );

      // Additionnal stored parameters :

      /*
       * Example for a library info property representing the Bayeux resources
       * installation directory:
       *
       * // with hardcoded path:
       *
       * lib_infos.store_string(datatools::library_info::INSTALL_RESOURCE_DIR,
       *                      "@CMAKE_INSTALL_PREFIX@/@CMAKE_INSTALL_DATADIR@");
       *
       * // or dynamic (in case Bayeux should be relocatable, we use a runtime function
       * to guess the correct path):
       *
       * lib_infos.store_string(datatools::library_info::INSTALL_RESOURCE_DIR,
       *                        bayeux::resource::get_resource_dir());
       *
       */

      bayeux_lib_infos.store_string(datatools::library_info::LIBNAME,
                                    "Bayeux");
      bayeux_lib_infos.store_string(datatools::library_info::INSTALL_LIB_DIR,
                                    "@CMAKE_INSTALL_PREFIX@/lib");
      bayeux_lib_infos.store_string(datatools::library_info::INSTALL_INCLUDE_DIR,
                                    "@CMAKE_INSTALL_PREFIX@/include");
      bayeux_lib_infos.store_string(datatools::library_info::INSTALL_BIN_DIR,
                                    "@CMAKE_INSTALL_PREFIX@/bin");
      bayeux_lib_infos.store_integer(datatools::library_info::VERSION_MAJOR,
                                     bayeux::version::get_major());
      bayeux_lib_infos.store_integer(datatools::library_info::VERSION_MINOR,
                                     bayeux::version::get_minor());
      bayeux_lib_infos.store_integer(datatools::library_info::VERSION_PATCH,
                                     bayeux::version::get_patch());
      bayeux_lib_infos.store_string(datatools::library_info::MODULES, "@Bayeux_SUBMODULES@");
      bayeux_lib_infos.store_string(datatools::library_info::URL, "https://nemo.lpc-caen.in2p3.fr/wiki/Software/Bayeux");
      bayeux_lib_infos.store_string(datatools::library_info::AUTHORS, "FranÃ§ois Mauger, Xavier Garrido, Ben Morgan");
      bayeux_lib_infos.store_string(datatools::library_info::COPYRIGHT, "GNU General Public License version 3 or later");
    }

    if (datatools::library_info::logging() >= datatools::logger::PRIO_TRACE) {
      DT_LOG_TRACE(datatools::library_info::logging() == datatools::logger::PRIO_TRACE,
                   "Status of the library info register: " );
      datatools::library_info::status(std::cerr);
    }
    initialized = true;
  }
  DT_LOG_TRACE(datatools::library_info::logging() == datatools::logger::PRIO_TRACE, "Exiting." );
  return;
}

__attribute__((destructor))
static void bayeux_finalizer()
{
  DT_LOG_TRACE(datatools::library_info::logging() == datatools::logger::PRIO_TRACE, "Entering...");
  if (datatools::library_info::has("bayeux")) {
    datatools::library_info::unregistration("bayeux");
  }
  if (datatools::library_info::has("dpp")) {
    datatools::library_info::unregistration("dpp");
  }
  if (datatools::library_info::has("brio")) {
    datatools::library_info::unregistration("brio");
  }
  if (datatools::library_info::has("trackfit")) {
    datatools::library_info::unregistration("trackfit");
  }
  if (datatools::library_info::has("genvtx")) {
    datatools::library_info::unregistration("genvtx");
  }
  if (datatools::library_info::has("genbb_help")) {
    datatools::library_info::unregistration("genbb_help");
  }
  if (datatools::library_info::has("emfield")) {
    datatools::library_info::unregistration("emfield");
  }
  if (datatools::library_info::has("geomtools")) {
    datatools::library_info::unregistration("geomtools");
  }
  if (datatools::library_info::has("mygsl")) {
    datatools::library_info::unregistration("mygsl");
  }
  if (datatools::library_info::has("materials")) {
    datatools::library_info::unregistration("materials");
  }
  if (datatools::library_info::has("cuts")) {
    datatools::library_info::unregistration("cuts");
  }
  DT_LOG_TRACE(datatools::library_info::logging() == datatools::logger::PRIO_TRACE, "Exiting." );
  return;
}

// end of bayeux/_init_fini.cc
