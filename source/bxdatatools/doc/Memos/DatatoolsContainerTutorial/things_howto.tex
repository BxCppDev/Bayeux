%% things_howto.tex
\section{The \texttt{datatools::utils::things} class}\label{sec:things}

\subsection{Introduction}

The  \texttt{datatools::utils::things} class  is a  general container.
It is able to store various  types of objects, depending on the needs.
It  is  serializable and  implements  a  dictionary interface.  Stored
objects must fulfill a special interface.

\subsection{Header file and instantiation}

\pn  In   order  to  use  \texttt{datatools::utils::things}
objects, one must use the following include directive:
\begin{CppVerbatim} 
#include <datatools/utils/things.h>
\end{CppVerbatim}

\pn The  declaration of a \texttt{datatools::utils::things}
instance can be simply done with:
\begin{CppVerbatim} 
datatools::utils::things my_bag;
\end{CppVerbatim}
\pn Note  the use  of the nested  \texttt{datatools::utils} namespace.
Alternatively one can use :
\begin{CppVerbatim} 
using namespace datatools::utils;
multi_properties my_bag;
\end{CppVerbatim}
\pn or:
\begin{CppVerbatim} 
namespace du = datatools::utils;
du::multi_properties my_bag;
\end{CppVerbatim}

\subsection{Design}

\subsubsection{Basics concept}

A  \emph{things} container  allows  to store  an  arbitrary number  of
objects   of    any   type,    provided   they   inherit    from   the
\texttt{datatools::serialization::i\_serializable}   interface.   This
design choice has  been done to enable the  \emph{things} container to
be serializable itself, using the Boost/Serialization mechanism as the
native I/O  system. Also a  \emph{things} container can  store another
\emph{things}   container.  Note  that   the  implementation   of  the
\texttt{datatools::utils::things}   class  relies   on   runtime  type
identification (RTTI) functionnalities of the C++ language.

\subsubsection{Banks}

A  \emph{things}  container  behaves  like a  dictionnary  and  stored
objects  -- we  also  speak  about \emph{banks}  --  must be  accessed
through  a unique  \emph{key}  (or name).  As  it is  not possible  to
automatically  \emph{guess} the type  of objects  once they  have been
stored in the  container, one has to use  templatized methods to check
and  manipulate  them.  However,  a special  \emph{serialization  tag}
associated to the stored object is also stored in order to enable some
further type identification or introspection functionnalities.

Finally the  \emph{things} container stores  objects through pointers,
and  is  responsible  of   the  corresponding  memory  allocation  and
deallocation of its contents.  The consequences of this implementation
are:
\begin{itemize}

\item the stored  objects can only be manipulated  by const or mutable
  \emph{references},

\item      the     \texttt{datatools::utils::things}      class     is
  \emph{non-copyable}.

\end{itemize}

\pn Despite these features (or limitations), the  \emph{things} container
is a very flexible container that is adapted for many applications.
It provides some powerfull management tools :
\begin{itemize}

\item add/remove arbitrary \emph{banks} of data 
  (with the serializable interface),

\item internal dynamic memory management,

\item manipulation of the data stored in banks through references.

\item a dictionnary interface to check and access to \emph{banks} of data,

\item fully serializable (Boost/Serialization).

\end{itemize}


\subsubsection{Interface}

\pn List of public \texttt{datatools::utils::things} class methods :
\begin{itemize}

\item \texttt{size} : return the number of stored objects/banks,

\item \texttt{empty} : check if the container is empty,

\item   \texttt{reset},    \texttt{clear}   :   remove    all   stored
  objects/banks,

\item \texttt{has}: check if an object/bank with a given name is stored,

\item \texttt{has\_serial\_tag}: 
  check if an object/bank with a given name and given \emph{serialization tag} 
  is stored,

\item \texttt{set\_constant}  : mark an object/bank with  a given name as
  non-mutable,

\item \texttt{is\_constant}  : check if an object/bank  with a given name
  is marked as non-mutable,

\item \texttt{is\_mutable} : check if an object/bank with a given name is
  mutable,

\item   \texttt{set\_description}  :   set   the  description   string
  associated to an object/bank with a given name,

\item   \texttt{get\_description}  :   get   the  description   string
  associated to an object/bank with a given name,

\item \texttt{get\_names} : get the list of names (keys) associated to
  all object/bank stored in the things container,

\item \texttt{remove},  \texttt{erase} : remove  an object/bank stored
  with a given name,

\item \texttt{tree\_dump} : prints the container in a human friendly format.

\end{itemize}

\pn List  of public  template methods for  the manipulation  of stored
objects/banks :

\begin{itemize}

\item \texttt{add<T>} : add a new object/bank of type \texttt{T} with
  a given name, return a mutable reference to the new allocated instance,

\item \texttt{is\_a<T>} : check if an existing object/bank with a given 
  name is of type \texttt{T},

\item \texttt{get<T>} : return a non-mutable reference to an existing object/bank 
  with a given name of type \texttt{T},

\item \texttt{grab<T>} : return a mutable reference to an existing object/bank 
  with a given name of type \texttt{T}.

\end{itemize}

\subsection{Examples}

\subsubsection{Declare a \emph{things} container and add objects in it}

\pn The  program source sample  \ref{program:things:0} shows
how to declare a \emph{things} container object and add two \emph{properties}
objects in it. It prints
the  contents of  the container  in a  human readable  formaty (sample
\ref{sample:things:0}.

\begin{program}[h]
\VerbatimInput[frame=single,
numbers=left,
numbersep=2pt,
firstline=1,
fontsize=\footnotesize,
showspaces=false]{\codingpath/things_0.cxx}
\caption{Adding objects in  a
  \texttt{datatools::utils::things} container. Note that all low-level
  memory allocation operation is performed internally. The user does not
  have to care about it.  
}
\label{program:things:0}
\end{program}



\begin{sample}[h]
\VerbatimInput[frame=single,
numbers=left,
numbersep=2pt,
firstline=1,
%lastline=3,
fontsize=\footnotesize,
showspaces=false]{\codingpath/things_0.out}
\caption{The  output of the  program \ref{program:things:0}.
  We  can  check that  the  two banks of data  have been  stored. Both are
  \texttt{datatools::utils::properties} objects, which are empty here.
}
\label{sample:things:0}
\end{sample}


\subsubsection{Instant manipulation of added objects through references}

\pn The  program source sample  \ref{sample:things:1} shows
how to declare a \emph{things} container object, add two \emph{properties}
objects in it and make use of the mutable reference returned by the template 
\texttt{add} methods.

\begin{sample}[h]
\VerbatimInput[frame=single,
numbers=left,
numbersep=2pt,
firstline=13,
lastline=26,
fontsize=\footnotesize,
showspaces=false]{\codingpath/things_1.cxx}
\caption{We use the references returned while adding objects in  a
  \texttt{datatools::utils::things} container in order to manipulate
  the stored object.  
}
\label{sample:things:1}
\end{sample}


\subsubsection{Get references to manipulate stored objects}

\pn  The  program source  sample  \ref{sample:things:2}  shows how  to
obtain non-mutable  and mutable  references to an  object stored  in a
\emph{things} container object with a given name.  The \texttt{get<T>}
and \texttt{grab<T>} template  methods respectively return non-mutable
and   mutable  references  (here   class  \texttt{T}   corresponds  to
\texttt{datatools::utils::properties}).  The  references are then used
to manipulate the stored object through its own interface.

\begin{sample}[h]
\VerbatimInput[frame=single,
numbers=left,
numbersep=2pt,
firstline=28,
lastline=42,
fontsize=\footnotesize,
showspaces=false]{\codingpath/things_1.cxx}
\caption{We explicitely  initialize references to an  object stored in
  the   \texttt{datatools::utils::things}   container   in  order   to
  manipulate the stored object.  }
\label{sample:things:2}
\end{sample}

\subsubsection{Create a new class to be stored in a \emph{things} container}

\pn The  program source samples  \ref{program:things:2a}
and \ref{program:things:2b} shows
how to declare new serializable class \texttt{storable\_type} that can be
stored in a \emph{things} container object (output is shown on sample
\ref{sample:things:2}).

\begin{program}[h]
\VerbatimInput[frame=single,
numbers=left,
numbersep=2pt,
firstline=1,
lastline=53,
fontsize=\footnotesize,
showspaces=false]{\codingpath/things_2.cxx}
\caption{Creation of a new storable class for
  \texttt{datatools::utils::things} container.
}
\label{program:things:2a}
\end{program}

\begin{program}[h]
\VerbatimInput[frame=single,
numbers=left,
numbersep=2pt,
firstline=56,
fontsize=\footnotesize,
showspaces=false]{\codingpath/things_2.cxx}
\caption{Program  to   store  a   new  storable  class   (see  program
  \ref{program:things:2a})   in   a  \texttt{datatools::utils::things}
  container.  }
\label{program:things:2b}
\end{program}


\begin{sample}[h]
\VerbatimInput[frame=single,
numbers=left,
numbersep=2pt,
firstline=1,
%lastline=3,
fontsize=\footnotesize,
showspaces=false]{\codingpath/things_2.out}
\caption{The          output          of          the          program
  \ref{program:things:2a}-\ref{program:things:2b}.  }
\label{sample:things:2}
\end{sample}

%% end of things_howto.tex
