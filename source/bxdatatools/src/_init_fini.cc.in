/* datatools/_init_fini.cc
 */
// Ourselves

// This package:
#include <datatools/datatools_config.h>
#include <datatools/library_info.h>
#include <datatools/properties.h>
#include <datatools/version.h>

__attribute__((constructor))
static void datatools_initializer()
{
  DT_LOG_TRACE(datatools::library_info::logging() == datatools::logger::PRIO_TRACE,
               "Entering...");
  static bool initialized = false;
  if (! initialized) {
    datatools::properties & lib_infos
      = datatools::library_info::registration("datatools",
                                              "Serializable data structures based on Boost "
                                              "and general purpose utility classes and macros.",
                                              datatools::version::get_version(),
                                              "@CMAKE_INSTALL_PREFIX@",                        // Hardcoded for now
                                              "@CMAKE_INSTALL_PREFIX@/@CMAKE_INSTALL_LIBDIR@", // Hardcoded for now
                                              "@CMAKE_INSTALL_PREFIX@/@CMAKE_INSTALL_DATADIR@" // Hardcoded for now
                                              );

    /* If needed, we could replace the hardcoded paths above by some
     * calls to runtime API methods (particulary for relocatable lib):
     *
     *   datatools::install::get_prefix()
     *   datatools::install::get_lib_dir()
     *   datatools::install::get_data_dir()
     *
     * as it is done with : datatools::version::get_version()
     */
    // Additionnal stored parameters :

    lib_infos.store_integer(datatools::library_info::VERSION_MAJOR,
                            datatools::version::get_major());
    lib_infos.store_integer(datatools::library_info::VERSION_MINOR,
                            datatools::version::get_minor());
    lib_infos.store_integer(datatools::library_info::VERSION_PATCH,
                            datatools::version::get_patch());
    lib_infos.store_boolean("with_bio",
                            DATATOOLS_WITH_BIO);
    lib_infos.store_boolean("with_reflection",
                            DATATOOLS_WITH_REFLECTION);
    lib_infos.store_string(datatools::library_info::BUILD_TYPE,
                           "@CMAKE_BUILD_TYPE@");

    if (datatools::library_info::logging() >= datatools::logger::PRIO_TRACE) {
      DT_LOG_TRACE(datatools::library_info::logging() == datatools::logger::PRIO_TRACE,
                   "Status of the library info register: " );
      datatools::library_info::status(std::cerr);
    }
    initialized = true;
  }
  DT_LOG_TRACE(datatools::library_info::logging() == datatools::logger::PRIO_TRACE, "Exiting.");
  return;
}

__attribute__((destructor))
static void datatools_finalizer()
{
  DT_LOG_TRACE(datatools::library_info::logging() == datatools::logger::PRIO_TRACE, "Entering...");
  if (datatools::library_info::has("datatools")) {
    datatools::library_info::unregistration("datatools");
  }
  DT_LOG_TRACE(datatools::library_info::logging() == datatools::logger::PRIO_TRACE, "Exiting." );
  return;
}

// end of datatools/_init_fini.cc
