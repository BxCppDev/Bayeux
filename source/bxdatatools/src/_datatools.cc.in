/* _datatools.cc */
// Ourselves
#include <datatools/datatools.h>

// This package:
#include <datatools/kernel.h>
#include <datatools/library_info.h>
#include <datatools/version.h>

namespace datatools {

  void _special_initialize_impl()
  {
#if DATATOOLS_BUNDLED == 0
    DT_THROW_IF(!datatools::kernel::is_instantiated(),
                std::runtime_error,
                "The datatools kernel is not instantiated !");
    datatools::kernel & krnl = datatools::kernel::instance();

    // Populate the library info register:
    if (krnl.has_library_info_register()) {
      // Registration of the datatools component in the kernel's library info register:
      datatools::library_info & lib_info_reg = krnl.grab_library_info_register();
      if (! lib_info_reg.has("datatools")) {
        datatools::properties & lib_infos
          = lib_info_reg.registration("datatools",
                                      "Serializable data structures based on Boost "
                                      "and general purpose utility classes and macros.",
                                      datatools::version::get_version(),
                                    "@CMAKE_INSTALL_PREFIX@",                        // Hardcoded for now
                                    "@CMAKE_INSTALL_PREFIX@/@CMAKE_INSTALL_LIBDIR@", // Hardcoded for now
                                    "@CMAKE_INSTALL_PREFIX@/@CMAKE_INSTALL_DATADIR@" // Hardcoded for now
                                    );

      /* If needed, we could replace the hardcoded paths above by some
       * calls to runtime API methods (particulary for relocatable lib):
       *
       *   datatools::install::get_prefix()
       *   datatools::install::get_lib_dir()
       *   datatools::install::get_data_dir()
       *
       * as it is done with : datatools::version::get_version()
       */
      // Additionnal stored parameters :

      lib_infos.store_integer(datatools::library_info::keys::version_major(),
                              datatools::version::get_major());

      lib_infos.store_integer(datatools::library_info::keys::version_minor(),
                              datatools::version::get_minor());

      lib_infos.store_integer(datatools::library_info::keys::version_patch(),
                              datatools::version::get_patch());

      lib_infos.store_boolean("with_bio",
                              DATATOOLS_WITH_BIO);

      lib_infos.store_boolean("with_reflection",
                              DATATOOLS_WITH_REFLECTION);

      lib_infos.store_string(datatools::library_info::keys::build_type(),
                             "@CMAKE_BUILD_TYPE@");

      if (lib_info_reg.get_logging() >= datatools::logger::PRIO_TRACE) {
        DT_LOG_TRACE(lib_info_reg.get_logging(),
                     "Status of the library info register: " );
        lib_info_reg.tree_dump(std::cerr);
      }
      }
    }
#else // DATATOOLS_BUNDLED == 0
#endif // DATATOOLS_BUNDLED == 0
    return;
  }

  void _special_terminate_impl()
  {
#if DATATOOLS_BUNDLED == 0
    if (datatools::kernel::is_instantiated()) {
      datatools::kernel & krnl = datatools::kernel::instance();
      if (krnl.has_library_info_register()) {

        // Access to the datatools kernel library info register:
        datatools::library_info & lib_info_reg = krnl.grab_library_info_register();

        // Unregistration of the datatools component in the kernel's
        // library info register:
        if (lib_info_reg.has("datatools")) {
          lib_info_reg.unregistration("datatools");
        }

        if (lib_info_reg.get_logging() >= datatools::logger::PRIO_TRACE) {
          DT_LOG_TRACE(lib_info_reg.get_logging(),
                       "Status of the library info register: " );
          lib_info_reg.tree_dump(std::cerr);
        }
      }
    }
#else // DATATOOLS_BUNDLED == 0
#endif // DATATOOLS_BUNDLED == 0
    return;
  }

} // end of namespace datatools

