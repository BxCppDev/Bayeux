#!/usr/bin/env bash
# -*- mode: shell-script; -*-
#
# pkgtool 
#
# Note: 
# This script has been generated by the 'pkgtools_create_package' program  
# from the  'pkgtools' package. 
#
# It suits  the use  of some default GNU/makefile generated in  
# the package 'gmk' directory.  
#

APPNAME="pkgtool"
appname=${APPNAME} 
the_base_dir=$(pwd)
the_python_dir=${the_base_dir}/python
the_gmk_dir=${the_base_dir}/gmk
the_pkgtools_dir=${the_base_dir}/pkgtools.d
libpkgtools_sh=${the_pkgtools_dir}/libpkgtools.sh 
if [ ! -f ${libpkgtools_sh} ]; then
    echo " ERROR:$APPNAME: Cannot find '${libpkgtools_sh}' setup file ! Abort !" >&2  
    exit 1
fi
source ${libpkgtools_sh}
export DATATOOLS_ROOT=${the_base_dir}

pkgtools__msg_not_using_verbose
pkgtools__msg_not_using_debug
pkgtools__msg_not_using_devel
pkgtools__msg_not_using_date
pkgtools__msg_using_color
pkgtools__ui_not_using_gui

pack_name=datatools
pack_name_upper=$(pkgtools__to_upper ${pack_name})
pack_name_lower=$(pkgtools__to_lower ${pack_name})
pack_config=${pack_name_lower}-config
config_db_file=${the_pkgtools_dir}/.config_db.info
config_sh_file=${the_pkgtools_dir}/.config_db.sh
config_csh_file=${the_pkgtools_dir}/.config_db.csh

# startup scripts
sh_ss=${pack_name_lower}.sh
csh_ss=${pack_name_lower}.csh
the_base_dir=$PWD
boost_version_check=1
#enforced_boost_version=1_38
enforced_boost_version=1_44_0

action_mode=""
do_usage=0
debug=0
verbose=0
#eos_trick=0

default_python_version=2.5
python_version=${default_python_version}
with_python=1

#apply_eos_archive_trick=0

function my_exit ()
{
    exit $1
}

function print_usage ()
{
    cat <<EOF

  $APPNAME (${pack_name})

  Usage:

    $APPNAME -h | --help : print this help then exit
  
  Available modes are:

    $APPNAME info        : print package info
    $APPNAME check       : check dependencies
    $APPNAME configure  [OPTIONS]: configure package 
            OPTIONS:
            --with-pba (default) :
              depends on Portable Binary Archive
            --without-pba :
              do not use Portable Binary Archive
            --with-fpu (default) :
              depends on Floating Point Utilities boost vault extension
            --without-fpu :
              do not use Floating Point Utilities boost vault extension
            --with-python :
              with Python wrapper module (default)
            --with-python-version VERSION :
              with Python version VERSION (default: 2.5)
            --without-python :
              without Python wrapper module
            --with-embedded-boost-io :
            --without-embedded-boost-io (default):
            --boost-version 1_44_0 : force Boost version (default: 1_44_0)
            --no-boost-version-check : skip Boost version check
    $APPNAME deconfigure : deconfigure package 
    $APPNAME build [OPTION] [TARGET] : build package
            OPTION: 
                --parallel    : try to run make using parallel process
            TARGET:
                lib (default) : build the shared library
                bin : build all executable programs (if any)
                bin_test : build all executable test programs (if any)
             or the name of a specific program, example:
                test_event_id : build only the 'test_event_id'  program

    $APPNAME doc        : generate doc
    $APPNAME undoc      : remove doc
    $APPNAME clean      : clean package
    $APPNAME install    : install package
    $APPNAME uninstall  : uninstall package

EOF
    return 0
}

#######################################################

parse_switch=1
while [ -n "$1" ]; do
    token="$1"
    if [ "${token:0:1}" = "-" ]; then
	opt=${token}
	if [ ${parse_switch} = 0 ]; then
	    break
	fi
	if [ "${opt}" = "-h" -o "${opt}" = "--help" ]; then
	    do_usage=1 
	elif [ "${opt}" = "-d" -o "${opt}" = "--debug" ]; then
	    pkgtools__msg_using_debug
	elif [ "${opt}" = "-v" -o "${opt}" = "--verbose" ]; then
	    pkgtools__msg_using_verbose
	else
	    pkgtools__msg_error "Invalid option!"
	    my_exit 1
	fi
    else
	arg=${token}
	parse_switch=0
	if [ -z "${action_mode}" ]; then
	    if [ "${arg}" = "configure" ]; then
		action_mode="configure"	
	    elif [ "${arg}" = "deconfigure" ]; then
		action_mode="deconfigure"	
	    elif [ "${arg}" = "build" ]; then
		action_mode="build"	
	    elif [ "${arg}" = "clean" ]; then
		action_mode="clean"	
	    elif [ "${arg}" = "install" ]; then
		action_mode="install"	
	    elif [ "${arg}" = "uninstall" ]; then
		action_mode="uninstall"	
	    elif [ "${arg}" = "info" ]; then
		action_mode="info"	
	    elif [ "$arg" = "check" ]; then
		action_mode="check"	
	    elif [ "${arg}" = "doc" ]; then
		action_mode="doc"	
	    elif [ "${arg}" = "undoc" ]; then
		action_mode="undoc"	
	    elif [ "${arg}" = "test" ]; then
		action_mode="test"	
	    elif [ "${arg}" = "untest" ]; then
		action_mode="untest"	
	    elif [ "${arg}" = "reset" ]; then
		action_mode="reset"	
	    elif [ "${arg}" = "list_of_actions" ]; then
		action_mode="list_of_actions"	
	    else
		pkgtools__msg_error "Invalid argument!"
		my_exit 1
	    fi
	else
	    # remaining arguments on command line are kept in "$@"
	    pkgtools__msg_devel "BREAK !"
	    break
	fi
    fi
    shift 1
done

pkgtools__msg_devel "action_mode=${action_mode}"
pkgtools__msg_devel "args=$@"

#######################################################

if [ ${do_usage} = 1 ]; then
    print_usage
    my_exit 2
fi

if [ -z "${action_mode}" ]; then
    pkgtools__msg_error "Missing action mode!"
    print_usage
    my_exit 2
fi

bn=$(basename $(pwd))
if [ "x$bn" = "xpkgtools.d" ]; then
    opwd=$(pwd)
    cd ..
    the_base_dir=$(pwd)
    cd $opwd
    unset opwd
elif [ -d ./pkgtools.d ]; then
    the_base_dir=$(pwd)
else 
    pkgtools__msg_error "Please run 'pkgtools.d/pkgtool' from the base package directory!"
    my_exit 1    
fi
#echo "Base package directory is '${the_base_dir}'!"

without_pba_flag_file=${the_base_dir}/gmk/datatools_without_pba.config
without_fpu_flag_file=${the_base_dir}/gmk/datatools_without_fpu.config
without_python_flag_file=${the_base_dir}/gmk/datatools_without_python.config
python_version_flag_file=${the_base_dir}/gmk/datatools_python_version.config
without_ebio_flag_file=${the_base_dir}/gmk/datatools_without_ebio.config

if [ -d ${the_base_dir}/gmk ]; then
    GMKDIR=${the_base_dir}/gmk
else
    pkgtools__msg_error "Missing gmk directory! Please run 'pkgtools.d/pkgtool' from the base package directory!"
    my_exit 1    
fi
python_dir=${the_base_dir}/python

#######################################################

function do_clean_gmk ()
{
    __pkgtools__at_function_enter do_clean_gmk

    if [ ! -d ${GMKDIR} ]; then 
	pkgtools__msg_error "do_clean_gmk: Missing '${GMKDIR}' directory!"
	__pkgtools__at_function_exit
	return 1
    fi
    opwd=$(pwd)
    cd ${GMKDIR}
    make clean 
    if [ $? -ne 0 ]; then 
	cd ${opwd}
	__pkgtools__at_function_exit
	return 1
    fi

    ### special Python wrapper/program:
    cd ${python_dir}
    make clean
    cd ${GMKDIR}
    ###

    cd ${opwd}
    __pkgtools__at_function_exit
    return 0
}

function do_build_gmk ()
{
    __pkgtools__at_function_enter do_build_gmk

    if [ ! -d ${GMKDIR} ]; then 
	pkgtools__msg_error "Missing '${GMKDIR}' directory!"
	__pkgtools__at_function_exit
	return 1
    fi
    opwd=$(pwd)
    cd ${GMKDIR}
    parallel_option=
    pkgtools__msg_debug "Option='$1'"
    if [ "x${1:0:1}" = "x-" ]; then
	if [ "x$1" = "x--parallel" ]; then
	    pkgtools__msg_warning "Using parallel build..."
	    parallel_option="-j"
	fi
	shift 1
    fi
    mk_lib=0
    mk_bin=0
    mk_bin_static=0
    build_tag=""
    if [ -z "$1" ]; then
	build_tag="lib"
    else
	build_tag="$1"
    fi	
    pkgtools__msg_info "target='${build_tag}'"
    old=0
    if [ $old -eq 1 ]; then
	if [ -z "$1" ]; then
	    mk_lib=0
	    mk_bin=1
	    mk_bin_static=0
	else
	    if [ "$1" = "lib" -o "$1" = "libs" ]; then
		mk_lib=1
	    fi
	    if [ "$1" = "bin" ]; then
		mk_bin=1
	    fi
	    if [ "$1" = "bin_static" ]; then
		mk_bin_static=1
	    fi
	    if [ "$1" = "all" ]; then
		mk_bin=1
		mk_bin_static=1
	    fi
	    if [ "$1" = "all_bin" -o "$1" = "bin_all" ]; then
		mk_bin=1
		mk_bin_static=1
	    fi
	fi
    #
	if [ $mk_lib = 1 ]; then
	    make ${parallel_option}
	    if [ $? -ne 0 ]; then
		__pkgtools__at_function_exit
		return 1
	    fi
	fi
	if [ $mk_bin = 1 ]; then
	    make ${parallel_option} bin 
	    if [ $? -ne 0 ]; then
		__pkgtools__at_function_exit
		return 1
	    fi
	fi
        #if [ $mk_bin_static = 1 ]; then
        #  make bin_static || return 1
        #fi
    else
	pkgtools__msg_info "Build target '${build_tag}'..."
	make ${parallel_option} ${build_tag}
	if [ $? -ne 0 ]; then
	    cd ${opwd} 
	    pkgtools__msg_error "Build target '${build_tag}' failed!"
	    __pkgtools__at_function_exit
	    return 1
	fi
    fi

    ### special Python wrapper/program:
    if [ ! -f ${without_python_flag_file} ]; then
	cd ${python_dir}
	make ${parallel_option}
	if [ $? -ne 0 ]; then
	    cd ${opwd} 
	    pkgtools__msg_error "Build Python stuff failed!"
	    __pkgtools__at_function_exit
	    return 1
	fi
	cd ${GMKDIR}
    fi
    ###

    cd ${opwd}
    __pkgtools__at_function_exit
    return 0
}

#######################################################

function do_test ()
{
    __pkgtools__at_function_enter do_test

    if [ -d ${the_gmk_dir} ]; then
	if [ -d ${the_python_dir} ]; then
	    if [ -f ${without_python_flag_file} ]; then
		source ${without_python_flag_file}
	    fi
	fi
	do_build_gmk test_dummy_${pack_name_lower}
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Build test program failed !"
	    __pkgtools__at_function_exit
	    return 1
	fi
	do_build_gmk test_properties
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Build 'test_properties' sample program failed !"
	    __pkgtools__at_function_exit
	    return 1
	fi
	do_build_gmk test_things
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Build 'test_things' sample program failed !"
	    __pkgtools__at_function_exit
	    return 1
	fi
    fi

    test_prog=test_dummy_${pack_name_lower}
    if [ -f ./programs/${test_prog}.cxx ]; then
	LD_LIBRARY_PATH=$(pkgtools__get_sys)/lib:${LD_LIBRARY_PATH} ./$(pkgtools__get_sys)/bin/${test_prog} 
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Test program '${test_prog}' failure !"
	    __pkgtools__at_function_exit
	    return 1
	else
	    pkgtools__msg_notice "Test program '${test_prog}' success !"
	fi
    fi

    __pkgtools__at_function_exit
    return 0
}

function do_untest ()
{
    __pkgtools__at_function_enter do_untest

    if [ -d ${the_gmk_dir} ]; then
	do_clean_gmk clean_bin_test
    fi

    pkgtools__msg_notice "Cleaning test files..."
    rm -f ${the_base_dir}/test_basic_event.xml
    rm -f ${the_base_dir}/test_binary_serialization.*
    rm -f ${the_base_dir}/test_data_serialization.*
    rm -f ${the_base_dir}/test_event_id.xml
    rm -f ${the_base_dir}/test_multi_properties.conf
    rm -f ${the_base_dir}/test_multi_properties.xml
    rm -f ${the_base_dir}/test_multi_properties_2.conf
    rm -f ${the_base_dir}/my_bag_of_bags.conf
    rm -f ${the_base_dir}/test_nans_ar.*
    rm -f ${the_base_dir}/test_properties.*
    rm -f ${the_base_dir}/my_bag.conf 

    rm -f ${the_base_dir}/test_serialization*.xml
    rm -f ${the_base_dir}/test_serialization*.data
    rm -f ${the_base_dir}/test_serialization*.txt

    rm -f ${the_base_dir}/test_things.*
    rm -f ${the_base_dir}/test_things_2.*

    __pkgtools__at_function_exit
    return 0
}

function do_undoc ()
{
    __pkgtools__at_function_enter do_undoc
    opwd=$(pwd)

    if [ -d ${the_base_dir}/doc/doxygen ]; then
	rm -fr ${the_base_dir}/doc/doxygen
    fi

    cd ${opwd}
    __pkgtools__at_function_exit
    return 0
}

function do_clean ()
{
    __pkgtools__at_function_enter do_clean

    opwd=$(pwd)
    pkgtools__msg_info "Clean package '${pack_name}'..."
    if [ -d ${GMKDIR} ]; then
	do_clean_gmk $@
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Clean package '${pack_name}' failed!"
	    __pkgtools__at_function_exit
	    return $?
	fi
    fi 


    cd ${opwd}
    __pkgtools__at_function_exit
    return 0
}

function boost_eos_archive_trick ()
{
    __pkgtools__at_function_enter boost_eos_archive_trick

    # force eos_portable_archive 4.1 trick:
    if [ "x${1}" != "x" ]; then
	eos_trick_ver="${1}"
    fi
    local eos_trick_ver=""
    local boost_version_rank=$(echo ${boost_version} | tr '_' '0')
    pkgtools__msg_notice "boost_version_rank=${boost_version_rank}"
    if [ ${boost_version_rank} -ge 104200 ]; then
	eos_trick_ver=4.1
    fi

    # Force 4.1 trick:
    eos_trick_ver=4.1
    
    # run the proper trick:
    if [ "x${eos_trick_ver}" = "x4.1" ]; then
	pkgtools__msg_notice "Running trick 4.1..."
	boost_eos_archive_trick_4_1
	__pkgtools__at_function_exit
	return
    fi
    # obsolete:
    if [ "x${eos_trick_ver}" = "x3.1" ]; then
	boost_eos_archive_trick_3_1
	__pkgtools__at_function_exit
	return
    fi
    pkgtools__msg_notice "Exiting."
    __pkgtools__at_function_exit
    return
}

function boost_eos_archive_trick_4_1 ()
{
    __pkgtools__at_function_enter boost_eos_archive_trick_4_1

    opwd=$(pwd) 
    cd ${the_base_dir}/boost/vault/eos

    ### fix input archive:
    pia_src=portable_iarchive.hpp
    if [ ! -f ${pia_src}.orig ]; then
	cp -f ${pia_src} ${pia_src}.orig 
    fi

    local boost_version_rank=$(echo ${boost_version} | tr '_' '0')
    if [ ${boost_version_rank} -ge 104000 -a ${boost_version_rank} -le 104300 ]; then
        cat ${pia_src}.orig | sed 's@set_library_version(3)@set_library_version((version_type)3)@g' > ${pia_src}
    elif [ ${boost_version_rank} -ge 104400 ]; then
        cat ${pia_src}.orig |
        sed -e 's@set_library_version(3)@set_library_version((library_version_type)3)@g' \
            -e 's@version_type input_library_version;@library_version_type input_library_version;@g' > ${pia_src}
    fi        
    
    cd ${opwd}

    pkgtools__msg_notice "boost_eos_archive_trick_4_1: Exiting."
    __pkgtools__at_function_exit
    return
}

function boost_eos_archive_trick_3_1 ()
{
    __pkgtools__at_function_enter boost_eos_archive_trick_3_1

    pkgtools__msg_notice "boost_eos_archive_trick_3_1: From 'http://www.boost.org/doc/libs/1_40_0/libs/serialization/doc/release.html#requirements'"

    opwd=$(pwd) 
    cd ${the_base_dir}/boost/vault/eos

    ### input archive:
    pia_src=portable_iarchive.hpp
    if [ ! -f ${pia_src}.orig ]; then
	cp -f ${pia_src} ${pia_src}.orig 
    fi
    ### output archive:	
    poa_src=portable_oarchive.hpp
    if [ ! -f ${poa_src}.orig ]; then
	cp -f ${poa_src} ${poa_src}.orig 
    fi

    version=2

    if [ ${version} -eq 2 ]; then
        ### input archive:
	cp -f ../eos_trick/portable_iarchive.trick.hpp ${pia_src}
        ### output archive:
	cp -f ../eos_trick/portable_oarchive.trick.hpp ${poa_src}
    fi

    if [ ${version} -eq 1 ]; then
        ### input archive:

	cat >>portable_iarchive__trick_1.hpp<<EOF
#if BOOST_VERSION < 104000
#include <boost/archive/impl/archive_pointer_iserializer.ipp>
#else 
#ifndef __eos_archive_serializer_map
#define __eos_archive_serializer_map
#include <boost/archive/impl/archive_serializer_map.ipp>
#endif
#endif 
EOF
	
	cat >>portable_iarchive__trick_2.hpp<<EOF
#if BOOST_VERSION < 104000
	template class detail::archive_pointer_iserializer<eos::portable_iarchive>;
#else 
	template class detail::archive_serializer_map<eos::portable_iarchive>;
#endif 
EOF
	cat ${pia_src}.orig | sed 's@#include <boost/archive/impl/archive_pointer_iserializer.ipp>@#include "portable_iarchive__trick_1.hpp"@g' > ${pia_src}.tmp1
	cat ${pia_src}.tmp1 | sed 's@^[[:space:]*]template class detail::archive_pointer_iserializer<eos::portable_iarchive>;@#include "portable_iarchive__trick_2.hpp"@g' > ${pia_src}
	rm -f ${pia_src}.tmp1
	
        ### output archive:	
	cat >>portable_oarchive__trick_1.hpp<<EOF
#if BOOST_VERSION < 104000
#include <boost/archive/impl/archive_pointer_iserializer.ipp>
#else 
#ifndef __eos_archive_serializer_map
#define __eos_archive_serializer_map
#include <boost/archive/impl/archive_serializer_map.ipp>
#endif 
#endif 
EOF
	
	cat >>portable_oarchive__trick_2.hpp<<EOF
#if BOOST_VERSION < 104000
	template class detail::archive_pointer_iserializer<eos::portable_oarchive>;
#else 
	template class detail::archive_serializer_map<eos::portable_oarchive>;
#endif 
EOF
	
	cat ${poa_src}.orig | sed 's@#include <boost/archive/impl/archive_pointer_oserializer.ipp>@#include "portable_oarchive__trick_1.hpp"@g' > ${poa_src}.tmp1
	cat ${poa_src}.tmp1 | sed 's@^[[:space:]*]template class detail::archive_pointer_oserializer<eos::portable_oarchive>;@#include "portable_oarchive__trick_2.hpp"@g' > ${poa_src}
	rm -f ${poa_src}.tmp1
    fi

    cd ${opwd}

    pkgtools__msg_notice "boost_eos_archive_trick_3_1: Exiting."
}

function get_dependency_package_config ()
{  
    __pkgtools__at_function_enter get_dependency_package_config
    dep=$1
    if [ "x${dep}" = "x" ]; then
	__pkgtools__at_function_exit
	return 1
    fi
    dep_cfg=
    dep_lower=$(echo ${dep} | tr 'A-Z' 'a-z')

    if [ "x"${dep_lower} == "mysql" ]; then
	dep_cfg=mysql_config
    else
	dep_cfg=${dep_lower}-config
    fi
    echo ${dep_cfg}

    __pkgtools__at_function_exit
    return 0
}

### This is a default algorithm to check dependencies.
### you may rewrite this function to suit your needs.
function check_dependencies ()
{
    __pkgtools__at_function_enter check_dependencies

   
    pkgtools__check_dependencies ${the_pkgtools_dir}/package.info $@
    if [ $? -ne 0 ]; then
	pkgtools__msg_warning "Invalid dependency !"
	__pkgtools__at_function_exit
	return 1
    fi

    __pkgtools__at_function_exit
    return 0;
}

function do_check ()
{
    __pkgtools__at_function_enter do_check

    can_python_wrapper=0
    with_python_wrapper=0
    if [ -f ${the_python_dir}/__init__.py ]; then
	can_python_wrapper=1
	with_python_wrapper=1
    fi

    skip_all_dependencies_check=0
    skipped_dependencies=
    while [ -n "$1" ]; do
	token="$1"
	    
	if [ "x${token:0:1}" = "x-" ]; then
	    opt=${token}
	    if [ "${opt}" = "-S" -o "${opt}" = "--skip-all-dependencies-check" ]; then
		skip_all_dependencies_check=1
	    elif [ "${opt}" = "-s" -o "${opt}" = "--skip-dependency-check" ]; then
		shift 1
		swpack=$1
		pkgtools__msg_debug "swpack = '${swpack}'"
		if [ "x${skipped_dependencies}" = "x" ]; then
		    skipped_dependencies=${swpack}
		else
		    skipped_dependencies="${skipped_dependencies} ${swpack}"
		fi
	    elif [ ${can_python_wrapper} -eq 1 ]; then
                # parse Python wrapper switches:
		if [ "x${opt}" = "x--with-python" ]; then
			with_python_wrapper=1
		elif [ "x${opt}" = "x--without-python" ]; then
		    with_python_wrapper=0
		fi
	    elif [ "${opt}" = "--prefix" ]; then
		shift 1
		prefix="$1"
	    else
                # parse other configuration options...
		pkgtools__msg_warning "Ignoring '${opt}' option !"
	    fi
	else
	    arg=${token}
	    pkgtools__msg_warning "Ignoring '${arg}' argument !"
	fi

	shift 1
    done

    pkgtools__msg_debug "skipped_dependencies = '${skipped_dependencies}'"

    if [ ${skip_all_dependencies_check} -eq 0 ]; then
        # Check package dependencies:
	check_dependencies ${skipped_dependencies}
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Dependencies check failed !"
	    __pkgtools__at_function_exit
	    return 1
	fi
    else
	pkgtools__msg_warning "No dependency check !"
    fi

    ok=1
    if [ ${can_python_wrapper} -eq 1 ]; then

	if [ ${with_python_wrapper} -eq 1 ]; then
	    pkgtools__msg_notice "Check Boost.Python avaibility !"
	    which boost-config > /dev/null
	    if [ $? -ne 0 ]; then
		pkgtools__msg_error "Boost is not setup !"
		pkgtools__msg_error "The 'boost_help' package is not setup !"
		ok=0
		#__pkgtools__at_function_exit
		#return 1
	    fi
	    pkgtools__msg_info "The 'boost_help' package seems ok !"
	    boost_python_check=$(boost-config --librairies | grep python)
	    if [ "x${boost_python_check}" = "x" ]; then
		pkgtools__msg_error "No Boost.Python library !"
		ok=0
		#__pkgtools__at_function_exit
		#return 1
	    fi
	    pkgtools__msg_notice "Python wrapper module from Boost.Python is usable  !"
	else
	    pkgtools__msg_error "Python wrapper module from Boost.Python is not usable !"
	fi
 
    fi

    __pkgtools__at_function_exit
    return 0
}

function do_deconfigure ()
{
    __pkgtools__at_function_enter do_deconfigure

    opwd=$(pwd)
 
    pkgtools__remove_file ${config_db_file}
    pkgtools__remove_file ${config_sh_file}
    pkgtools__remove_file ${config_csh_file}

    # old scheme is still here :
    # test -f ${without_pba_flag_file}     && rm -f ${without_pba_flag_file} 
    # test -f ${without_fpu_flag_file}     && rm -f ${without_fpu_flag_file} 
    # test -f ${without_python_flag_file}  && rm -f ${without_python_flag_file} 
    # test -f ${python_version_flag_file}  && rm -f ${python_version_flag_file} 
    # test -f ${without_ebio_flag_file}    && rm -f ${without_ebio_flag_file} 
   
    cd ${the_base_dir}/boost/vault
    pkgtools__msg_info "Remove the Boost vault contribution(s) in the '$(pwd)' directory..."
    make clean
    if [ $? -ne 0 ]; then
	pkgtools__msg_error "Removal of the Boost vault contribution(s) from '${pack_name}' failed!"
	__pkgtools__at_function_exit
	return $?
    fi
    cd ${opwd}

    __pkgtools__at_function_exit
    return 0
}

function do_configure ()
{
    __pkgtools__at_function_enter do_configure

    pkgtools__remove_file ${config_db_file}
    pkgtools__remove_file ${config_sh_file}
    pkgtools__remove_file ${config_csh_file}
    echo "# ${pack_name} configuration informations : " >> ${config_db_file}

    local can_python_wrapper=0
    local with_python_wrapper=0
    
    if [ -f ${the_python_dir}/__init__.py ]; then
	can_python_wrapper=1
	with_python_wrapper=1
    fi

    local with_pba=1
    local with_fpu=1
    local with_ebio=0
    local enforced_boost_version=
    python_version=
    local skip_all_dependencies_check=0
    local skipped_dependencies=
    while [ -n "${1}" ]; do
	local token="$1"
	if [ "x${token:0:1}" = "x-" ]; then
	    local opt=${token}
	    if [ "${opt}" = "-S" -o "${opt}" = "--skip-all-dependencies-check" ]; then
		skip_all_dependencies_check=1
	    elif [ "${opt}" = "-s" -o "${opt}" = "--skip-dependency-check" ]; then
		{
		    shift 1
		    swpack=$1
		    if [ "x${skipped_dependencies}" = "x" ]; then
			skipped_dependencies=${swpack}
		    else
			skipped_dependencies="${skipped_dependencies} ${swpack}"
		    fi
		}
	    elif [ "x${opt}" = "x--with-pba" ]; then
		with_pba=1
		with_fpu=1
	    elif [ "x${opt}" = "x--without-pba" ]; then
		with_pba=0
	    elif [ "x${opt}" = "x--with-fpu" ]; then
		with_fpu=1
	    elif [ "x${opt}" = "x--without-fpu" ]; then
		with_fpu=0
		with_pba=0
	    elif [ "x${opt}" = "x-ebio" -o "x${opt}" = "x--with-embedded-boost-io" ]; then
		with_ebio=1
	    elif [ "x${opt}" = "x-no-ebio" -o "x${opt}" = "x--without-embedded-boost-io" ]; then
		with_ebio=0
	    elif [ "x${opt}" = "x--boost-version" ]; then
		shift 1
		enforced_boost_version=$1
	    elif [ "x${opt}" = "x--no-boost-version-check" ]; then
		boost_version_check=0
	    elif [ ${can_python_wrapper} -eq 1 ]; then
		{
                # parse Python wrapper switches:
		    if [ "x${opt}" = "x--with-python" ]; then
			with_python_wrapper=1
		    elif [ "x${opt}" = "x--with-python-version" ]; then
			shift 1
			python_version=$1
			with_python_wrapper=1
		    elif [ "x${opt}" = "x--without-python" ]; then
			with_python_wrapper=0
		    fi
		}
	    else	
		pkgtools__msg_warning "Ignoring '${opt}' option !"
	    fi
	else
	    arg=${token}
	    pkgtools__msg_warning "Ignoring '${arg}' argument !"
	fi

	shift 1
    done


    # please enter a list of software components you don't want
    # to check:
    # Example: 
    #   skipped_dependencies="gnuplot test dummy"

    if [ ${skip_all_dependencies_check} -eq 0 ]; then
	pkgtools__msg_notice "Checking some basic dependencies..."
        # Check package dependencies:
	check_dependencies ${skipped_dependencies}
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Dependencies check failed !"
	    __pkgtools__at_function_exit
	    return 1
	fi
    fi

    pkgtools__msg_notice "Specific checks for Boost..."
    which boost-config 2>&1 > /dev/null
    if [ $? -ne 0 ]; then
	pkgtools__msg_error "The 'boost_help' package is not setup!"
	__pkgtools__at_function_exit
	return 1
    fi
    if [ ${boost_version_check} -eq 1 ]; then
	boost_version=$(boost-config --version)
    fi

    if [ "x${enforced_boost_version}" = "x" ]; then
	enforced_boost_version=${boost_version}
    fi

    if [ ${with_ebio} -ne 0 ]; then
	pkgtools__msg_warning "Embedded pre-built Boost/Serialization code requires Boost >= 1.47"	
    fi

    if [ "x${boost_version}" != "x${enforced_boost_version}" ]; then
	pkgtools__msg_error "Boost has no version ${enforced_boost_version}!"
	__pkgtools__at_function_exit
	return 1
    else
	pkgtools__msg_notice "The 'boost_help' package uses Boost version '${enforced_boost_version}'"
    fi

    check_boost_python=$(boost-config --with-python)
    if  [ ${check_boost_python} -eq 0 ]; then
	pkgtools__msg_warning "Boost.Python library is not available!"
    else
	pkgtools__msg_notice "Boost.Python library is available!"
    fi

    ### Specific test for Python wrapper:
    if [ ${can_python_wrapper} -eq 1 ]; then
	
	if [ ${with_python_wrapper} -eq 1 ]; then
	    pkgtools__msg_notice "Check Boost.Python avaibility !"
	    which boost-config > /dev/null
	    if [ $? -ne 0 ]; then
		pkgtools__msg_error "Boost is not setup !"
		pkgtools__msg_error "The 'boost_help' package is not setup !"
		__pkgtools__at_function_exit
		return 1
	    fi
	    pkgtools__msg_info "The 'boost_help' package seems ok !"
	    boost_python_check=$(boost-config --librairies | grep python)
	    if [ "x${boost_python_check}" = "x" ]; then
		pkgtools__msg_error "No Boost.Python library !"
		__pkgtools__at_function_exit
		return 1
	    fi
	    pkgtools__msg_notice "Use Python wrapper module from Boost.Python !"
	    boost_python_version="$(boost-config --python-version)"
	    if [ "x${python_version}" = "x" ]; then
		python_version=${boost_python_version}
	    fi
	    if [ "x${python_version}" != "x${boost_python_version}" ]; then
		pkgtools__msg_error "Unmatching Python version with Boost ! Boost uses Python ${boost_python_version} !"
		__pkgtools__at_function_exit
		return 1
	    else
		pkgtools__msg_notice "Python version ${python_version} matches with the one used by Boost (${boost_python_version}) !"
	    fi 
	    
	    which python${python_version}-config 2>&1 > /dev/null
	    if [ $? -ne 0 ]; then
		pkgtools__msg_error "Python ${python_version} is not setup !"
		__pkgtools__at_function_exit
		return 1
	    else
		pkgtools__msg_notice "Python ${python_version} is setup !"
		echo "${python_version}" > ${python_version_flag_file}
	    fi
	    
	    if [ "x${python_version}" != "x${boost_python_version}" ]; then
		pkgtools__msg_error "Unmatching Python version with Boost! Boost uses Python ${boost_python_version}!"
		__pkgtools__at_function_exit
		return 1
	    fi
	else
	    pkgtools__msg_warning "Do not use Python wrapper module from Boost.Python !"
	    pkgtools__cfg_store_property ${config_db_file} "${pack_name_upper}_NO_PYTHON" 1
	fi # with_python_wrapper
    fi # can_python_wrapper

    ### Support for Portable binary archives:
    pkgtools__msg_notice "Portable Binary Archives setup..."
    if [ ${with_pba} -eq 0 ]; then
	pkgtools__msg_warning "Do not use Portable Binary Archives !"
	pkgtools__cfg_store_property ${config_db_file} "${pack_name_upper}_NO_PBA" 1
    else
	# 2010-12-06 FM:
	pkgtools__msg_notice "Use Portable Binary Archives !"
	with_fpu=1
    fi

    ### Support for Floating Point Utilities:
    pkgtools__msg_notice "Floating Point Utilities setup..."
    if [ ${with_fpu} -eq 0 ]; then
	pkgtools__msg_warning "Do not use Floating Point Utilities from the 'Boost/vault' package!"
	pkgtools__cfg_store_property ${config_db_file} "${pack_name_upper}_NO_FPU" 1
    else
	pkgtools__msg_notice "Use Floating Point Utilities from the Boost/vault!"
	opwd=$(pwd)
	cd ${the_base_dir}/boost/vault
	pkgtools__msg_notice "Cleaning the '$(pwd)' directory..."
	make clean 2>&1 > /dev/null
	pkgtools__msg_notice "Populating the '$(pwd)' directory..."
	make 2>&1 > /dev/null 
	cd ${opwd}
    fi

    ### Support for Embedded Boost I/O:
    pkgtools__msg_notice "Embedded Boost I/O:..."
    if [ ${with_ebio} -eq 0 ]; then
	pkgtools__msg_warning "Do not use Embedded Boost I/O !"
	pkgtools__cfg_store_property ${config_db_file} "${pack_name_upper}_NO_EBIO" 1
    else
	pkgtools__msg_notice "Use Embedded Boost I/O !"
    fi

    # ## 2010-12-06: Do not use the EOS archive trick anymore:
    # if [ ${apply_eos_archive_trick} -eq 1 ]; then
    # ### Special workaround for EOS Portable binary archives vs Boost version:
    # 	if [ ${with_pba} -eq 1 ]; then
    # 	    local boost_version_rank=$(echo ${boost_version} | tr '_' '0')
    # 	    pkgtools__msg_notice "boost_version_rank=${boost_version_rank}"
    # 	    run_eos_archive_trick=0
    # 	    if [ ${boost_version_rank} -ge 104000 ]; then
    # 		run_eos_archive_trick=1
    # 	    fi
    # 	# 2009-11-12 FM: force the trick for debugging purpose: 
    # 	#run_eos_archive_trick=1
    # 	    if [ ${run_eos_archive_trick} -eq 1 ]; then
    # 		pkgtools__msg_warning "Using special trick for EOS portable archives!"
    # 		boost_eos_archive_trick ${eos_trick}
    # 	    fi
    # 	fi
    # fi

    echo "# end of ${pack_name} configuration informations."          >> ${config_db_file} 
    cat ${config_db_file} | ${the_pkgtools_dir}/config_to_setup.py sh  > ${config_sh_file}
    cat ${config_db_file} | ${the_pkgtools_dir}/config_to_setup.py csh > ${config_csh_file}

    __pkgtools__at_function_exit
    return 0
}

function do_build ()
{
    __pkgtools__at_function_enter do_build

    if [ ! -f ${config_sh_file} ]; then
	pkgtools__msg_error "Missing '${config_sh_file}' file ! Please first configure !"
	__pkgtools__at_function_exit
	return 1	
    fi
    source ${config_sh_file}

    if [ -d ${GMKDIR} ]; then

	# if [ -f ${without_pba_flag_file} ]; then
	#     source ${without_pba_flag_file}
	# fi
	# if [ -f ${without_fpu_flag_file} ]; then
	#     source ${without_fpu_flag_file}
	# fi
	# if [ -f ${without_python_flag_file} ]; then
	#     source ${without_python_flag_file}
	# fi
	# if [ -f ${without_ebio_flag_file} ]; then
	#     source ${without_ebio_flag_file}
	# fi

	do_build_gmk $@
	if [ $? -ne 0 ]; then
	    __pkgtools__at_function_exit
	    return 1
	fi
    fi

    __pkgtools__at_function_exit
    return 0
}

function do_startup ()
{
    __pkgtools__at_function_enter do_startup

    pkgtools__msg_warning "SH startup = ${the_base_dir}/${sh_ss}"
    cat ${the_pkgtools_dir}/package.sh.skel | sed -e "s@__PACKAGE_ROOT__@${GEOMTOOLS_ROOT}@g" -e "s@__PACKAGE_NAME__@${pack_name_upper}@g" -e "s@__Package_name__@${pack_name}@g" > ${the_base_dir}/${sh_ss} 

    pkgtools__msg_warning "CSH startup = ${the_base_dir}/${csh_ss}"
    cat ${the_pkgtools_dir}/package.csh.skel | sed -e "s@__PACKAGE_ROOT__@${GEOMTOOLS_ROOT}@g" -e "s@__PACKAGE_NAME__@${pack_name_upper}@g" -e "s@__Package_name__@${pack_name}@g" > ${the_base_dir}/${csh_ss}

    cat ${config_sh_file}  >> ${the_base_dir}/${sh_ss}
    cat ${config_csh_file} >> ${the_base_dir}/${csh_ss}

    cat<<EOF

Setup scripts:

  '${the_base_dir}/${sh_ss}' for sh-shells

and  

  '${the_base_dir}/${csh_ss}' for csh-shells

have been generated.

You may source these scripts at startup time 
(i.e. from your '~/.bashrc' or '~/.(t)cshrc' files).

EOF
    __pkgtools__at_function_exit
    return 0
}

function kill_startup ()
{
    __pkgtools__at_function_enter kill_startup

    test -f ${the_base_dir}/${sh_ss} && rm -f  ${the_base_dir}/${sh_ss} || echo -n ""
    test -f ${the_base_dir}/${csh_ss} && rm -f  ${the_base_dir}/${csh_ss} || echo -n ""

    cat<<EOF
Don't forget to remove environment variables in your startup scripts.
Particularly, you should not source the following scripts anymore
from your '~/.bashrc' or '~/.(t)cshrc' files:

  '${the_base_dir}/${sh_ss}' for sh-shells

and  

  '${the_base_dir}/${csh_ss}' for csh-shells

EOF
    __pkgtools__at_function_exit
    return 0
}

function do_install ()
{
    __pkgtools__at_function_enter do_install

    if [ ! -f ${config_sh_file} ]; then
	pkgtools__msg_error "Missing '${config_sh_file}' file ! Please first configure and build !"
	__pkgtools__at_function_exit
	return 1	
    fi
    source ${config_sh_file}

    pkgtools__msg_info "Install package '${pack_name}'..."
    opwd=$(pwd)
    cd ${GMKDIR}

    make install 
    if [ $? -ne 0 ]; then 
	cd ${opwd}
	__pkgtools__at_function_exit
	return 1
    fi

    ### special Python wrapper/program:
    if [ ! -f ${without_python_flag_file} ]; then
	cd ${python_dir}
	make install
	cd ${GMKDIR}
    fi
    ###

    cd ${opwd}
    pkgtools__msg_debug "do_startup..."
    do_startup
    pkgtools__msg_debug "ok"

    local sysdir=${the_base_dir}/$(pkgtools__get_sys)
    test -L ${sysdir}/bin/${pack_config} && rm -f ${sysdir}/bin/${pack_config} 
    ln -s -f ${the_pkgtools_dir}/${pack_config} ${sysdir}/bin/${pack_config}

    __pkgtools__at_function_exit
    return 0
}

function do_uninstall ()
{
    __pkgtools__at_function_enter do_uninstall

    pkgtools__msg_info "Uninstall package '${pack_name}'..."
    opwd=$(pwd)
    cd ${GMKDIR}
    make uninstall 
    if [ $? -ne 0 ]; then 
	cd ${opwd}
	__pkgtools__at_function_exit
	return 1
    fi

    ### special Python wrapper/program:
    if [ -d ${the_python_dir} ]; then
	cd ${python_dir}
	make uninstall
	cd ${GMKDIR}
    fi
    ###

    cd ${opwd}
    kill_startup

    local sysdir=${the_base_dir}/$(pkgtools__get_sys)
    test -L ${sysdir}/bin/${pack_config} && rm -f ${sysdir}/bin/${pack_config} 

    if [ -f ${the_base_dir}/.cflags.cache ]; then
	rm -f  ${the_base_dir}/.cflags.cache
    fi

    if [ -f ${the_base_dir}/.ldflags.cache ]; then
	rm -f  ${the_base_dir}/.ldflags.cache
    fi

    __pkgtools__at_function_exit
    return 0
}

function do_info ()
{
    __pkgtools__at_function_enter do_info

    pkg_version="undefined"
    pkg_lang="undefined"
    pkg_creation="undefined"
    pkg_authors="undefined"
    pkg_deps="undefined"
    if [ -f ./VERSION ]; then
	pkg_version=$(cat ./VERSION)
    fi
    pkg_build="undefined"
    if [ -d ${GMKDIR} -a -f ${GMKDIR}/GNUmakefile ]; then
	pkg_build="GNU-make"
    fi
    if [ -f ./configure.ac -o -f ./configure.in ]; then
	pkg_build="Autotools"
    fi
    echo "This is package '${pack_name}' (version ${pkg_version})" #1>&2
    
    pkgi_file="./pkgtools.d/package.info"
    if [ -f ${pkgi_file} ]; then
	pkg_lang=$(cat ${pkgi_file} | grep "language=" | cut -d= -f2)
	pkg_creation=$(cat ${pkgi_file} | grep "creation=" | cut -d= -f2)
	pkg_authors=$(cat ${pkgi_file} | grep "author=" | cut -d= -f2)
	pkg_deps=$(cat ${pkgi_file} | grep "dependencies=" | cut -d= -f2)
	pkg_namespace=$(cat ${pkgi_file} | grep "namespace=" | cut -d= -f2)
	pkg_url=$(cat ${pkgi_file} | grep "URL=" | cut -d= -f2)
	pkg_svn=$(cat ${pkgi_file} | grep "SVN base repository=" | cut -d= -f2)
	echo -e "\tName               : ${pack_name}"
	echo -e "\tVersion            : ${pkg_version}"
	echo -e "\tLanguage is        : ${pkg_lang}"
	echo -e "\tDependencies are   : ${pkg_deps}"
	echo -e "\tAuthors            : ${pkg_authors}"
	echo -e "\tCreation date      : ${pkg_creation}"
	if [ "${pkg_lang}" = "C++" ]; then
	    echo -e "\tNamespace          : ${pkg_namespace}"
	fi
	echo -e "\tBuild method       : ${pkg_build}"
	echo -e "\tURL                : ${pkg_url}"
	echo -e "\tSVN base repository: ${pkg_svn}"
    fi

    __pkgtools__at_function_exit
    return 0
}

function do_undoc ()
{
    __pkgtools__at_function_enter do_undoc
    opwd=$(pwd)

    if [ -d ${the_base_dir}/doc/doxygen ]; then
	rm -fr ${the_base_dir}/doc/doxygen
    fi

    cd ${opwd}
    __pkgtools__at_function_exit
    return 0
}

function do_doc ()
{
    __pkgtools__at_function_enter do_doc

    pkgtools__msg_info "Generate documentation for package '${pack_name}'..."
    which doxygen >/dev/null 2>&1
    if [ $? -ne 0 ]; then
	pkgtools__msg_error "Cannot find doxygen !"
	__pkgtools__at_function_exit
	return 1
    fi
    if [ ! -f ${the_base_dir}/pkgtools.d/${pack_name}.doxygen ]; then
	pkgtools__msg_error "Missing '${the_base_dir}/pkgtools.d/${pack_name}.doxygen' configuration file !"
	__pkgtools__at_function_exit
	return 1
    fi
    # doxygen -g ${the_base_dir}/pkgtools.d/${pack_name}.doxygen
    doxygen ${the_base_dir}/pkgtools.d/${pack_name}.doxygen 
 
    pkgtools__msg_notice "Doxygen documentation is at: ${the_base_dir}/doc/doxygen/html/index.html"
    pkgtools__msg_notice "Please run: 'firefox file://$(pwd)/doc/doxygen/html/index.html &' or something similar..."
   
    __pkgtools__at_function_exit
    return 0
}

function do_reset ()
{
    __pkgtools__at_function_enter do_reset

    test -f .cflags.cache && rm -f .cflags.cache
    test -f .ldflags.cache && rm -f .ldflags.cache

    do_undoc
    do_untest
    do_uninstall
    do_clean
    do_deconfigure

    __pkgtools__at_function_exit
    return 0
}

#######################################################

function main ()
{
    __pkgtools__at_function_enter main
    
    # Some checks...
    if [ -z "${action_mode}" ]; then
	pkgtools__msg_error "Missing running mode !"
	print_usage
	__pkgtools__at_function_exit
	return 1
    fi

    if [ ! -d ./pkgtools.d ]; then
	pkgtools__msg_error "Please run the 'pkgtools.d/pkgtool' utility from the base package directory !"
	__pkgtools__at_function_exit
	return 1
    fi

    pkgtools__msg_debug "Base package directory is '${the_base_dir}' !"

    # Perform action...
    if [ "${action_mode}" = "configure" ]; then
	do_configure $@
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Configure failed !"
	    return 1
	fi
    fi

    if [ "${action_mode}" = "deconfigure" ]; then
	do_deconfigure $@
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "De-configure failed !"
	    return 1
	fi
    fi

    if [ "${action_mode}" = "build" ]; then
	do_build $@
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Build failed !"
	    return 1
	fi
    fi

    if [ "${action_mode}" = "clean" ]; then
	do_clean
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Clean failed !"
	    return 1
	fi
    fi

    if [ "${action_mode}" = "install" ]; then
	do_install
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Install failed !"
	    return 1
	fi
    fi

    if [ "${action_mode}" = "uninstall" ]; then
	do_uninstall
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Uninstall failed !"
	    return 1
	fi
    fi

    if [ "${action_mode}" = "info" ]; then
	do_info
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Info failed !"
	    return 1
	fi
    fi
    
    if [ "${action_mode}" = "check" ]; then
	do_check $@
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Package check failed !"
	    __pkgtools__at_function_exit
	    return 1
	fi
    fi

    if [ "${action_mode}" = "doc" ]; then
	do_doc
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Documentation failed !"
	    return 1
	fi
    fi

    if [ "${action_mode}" = "undoc" ]; then
	do_undoc
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Documentation removal failed !"
	    return 1
	fi
    fi

    if [ "${action_mode}" = "test" ]; then
	do_test
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Test material failed !"
	    return 1
	fi
    fi

    if [ "${action_mode}" = "untest" ]; then
	do_untest
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Test material removal failed !"
	    return 1
	fi
    fi

    if [ "${action_mode}" = "reset" ]; then
	do_reset
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Reset failed !"
	    return 1
	fi
    fi

    if [ "${action_mode}" = "list_of_actions" ]; then
	echo "list_of_actions info check configure deconfigure build clean install uninstall doc undoc test untest reset" 
	return 0
    fi

    __pkgtools__at_function_exit
    return 0
}

#######################################

main $@
if [ $? -ne 0 ]; then
    my_exit 1
fi
my_exit 0

# end of pkgtool
