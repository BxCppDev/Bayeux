
Use  case of  Boost serialization  through pointers  to objects  of an
abstract derived  class using  two DLLs. This  use case consists  in a
rather minimal  set of files that  illustrates some issues  I met with
Boost serialization across several DLLs. I have tried to follow the 
guidelines 


STEP 1 : The base DLL
---------------------

The DLL 'A' is the base  library. It uses the namespace 'A'.  It first
provides the abstract class  'A::base' with some pure virtual methods.

Class  'A::base'  is   serializable  through  the  Boost/Serialization
system.
Abase.hpp -> class declaration
Abase.ipp -> implementation of serialization features
	  - definition of the 'A::base::serialize' template method
	  - use of assume abstract              
	  - export key


The 'A::c1' class inherits the 'A::base' class:
Ac1.hpp -> class declaration
Ac1.cpp -> class definition
Ac1.ipp -> implementation of serialization features
	- definition of the 'A::c1::serialize' template method
	- export key


The 'A::c2' class inherits the 'A::base' class:
Ac2.hpp -> class declaration
Ac2.cpp -> class definition
Ac2.ipp -> implementation of serialization features
	- definition of the 'A::c2::serialize' template method
	- export key


The 'A::d1' class inherits the 'A::c1' class:
Ad1.hpp -> class declaration
Ad1.cpp -> class definition
Ad1.ipp -> implementation of serialization features
	- definition of the 'A::d1::serialize' template method
	- export key

Embed the serialization code within the 'A' DLL :
Aio.cpp -> implementation of serialization features 
	- export key for classes 'A::base', 'A::c1', 'A::c2', 'A::d1'
	  with automatic instantiation of serialization code for
	  text and XML archives

Compilation of  'Ac1.cpp', 'Ac2.cpp', 'Ad1.cpp' and  'Aio.cpp' is done
and the  resulting 'Ac1.o', 'Ac2.o', 'Ad1.o' and  'Aio.o' are archived
in the 'libA.so' shared library.

The class diagram is shown below:

>>>
  DLL A      
                 
A::base          
|                
+--------+
|        |       
A::c1    A::c2  
|                
|              
A::d1           
<<<
           
Three  sample  programs are  provided.  They  are  linked against  the
'libA.so' DLL:

- 'Aprg0.cxx' does  not make  use of any  serialization code  but just
prints instances of classes 'A::c1', 'A::c2' and 'A::d1'.

- 'Aprg1.cxx'  stores  and  loads  instances of  classes  'A::c1'  and
'A::c2' using text archives, using pointers to the 'A::base' class.

- 'Aprg2.cxx'  like  'Aprg1.cxx'  for  classes  'A::c1',  'A::c2'  and
  'A::d1'.

All programs compile and execute well. 



STEP 2 : A daughter DLL
-----------------------

The DLL 'B' is  designed on top of the base 'A'  library.  It uses the
namespace  'B'. It  provides  a new  serializable  class 'B::c3'  that
inherits from 'A::base' in such a way the class diagram is now:

>>>
      DLL A      :     DLL B
                 :
A::base          :
|                :
+--------+-------:-------+
|        |       :       |
A::c1    A::c2   :       B::c3
|                : 
|                :
A::d1            :  
                 :
<<<

The 'B::c3' class inherits the 'A::base' class:
Bc3.hpp -> class declaration
Bc3.cpp -> class definition
Bc3.ipp -> implementation of serialization features
	- definition of the 'B::c3::serialize' template method
	- export key

Embed the serialization code within the 'B' DLL :
Bio.cpp -> implementation of serialization features 
	- export key for class 'B::c3'
	  with automatic instantiation of serialization code for
	  text and XML archives

Compilation  of 'Bc3.cpp'  and  'Bio.cpp' is  done  and the  resulting
'Bc3.o' and 'Bio.o' are archived in the 'libB.so' shared library.
       
Some  sample  programs are  provided.   They  are  linked against  the
'libB.so' and 'libA.so' DLLs:


- 'Bprg0.cxx' does not make use  of serialization code but just prints
instances of classes 'A::c1', 'A::c2', 'A::d1' and 'B::c3'.

- 'Bprg1.cxx' stores and loads  instances of classes 'A::c1', 'A::c2',
'A::d1'  and  'B::c3'  using  text  archives, using  pointers  to  the
'A::base' class.

- 'Bprg2.cxx' and  'Bprg3.cxx' like 'Bprg1.cxx'  with different mixing
of classes in the archve.

My system is Linux with gcc 4.5.2 and Boost 1.44 :

>>>
bash$ cat /etc/lsb-release 
DISTRIB_ID=Ubuntu
DISTRIB_RELEASE=11.04
DISTRIB_CODENAME=natty
DISTRIB_DESCRIPTION="Ubuntu 11.04"

bash$ g++ --version
g++ (Ubuntu/Linaro 4.5.2-8ubuntu4) 4.5.2

bash$ boost-config --version
1_44_0
<<<

Both libraries 'A' and 'B' compile properly.
All programs in 'A' and 'B' compile and link properly.
All programs in 'A' execute properly.
Programs 'Bprg1.cxx', 'Bprg2.cxx' and 'Bprg3.cxx' from 'B'
execute properly.
The PROBLEM is that 'Bprg0.cxx' segfaults at termination.

>>>
$ LANG="C" ./Bprg0
o1 : c1={i=666}
o2 : c2={name='test'}
w1 : d1={i=9,j=1000}
o3 : c3={c=7}
Segmentation fault
<<<

I remind you that the difference between 'Bprg0.cxx' and say 'Bprg1.cxx'
is that  'Bprg0.cxx' does not make use serialization code.

A GDB session gives some hints  about the place the problem occurs but
I cannot  tell more about  it. It seems  it is related to  some broken
termination code for static singleton :

>>>
Program received signal SIGSEGV, Segmentation fault.
0x001ffec7 in boost::serialization::typeid_system::extended_type_info_typeid_0::is_less_than(boost::serialization::extended_type_info const&) const ()
   from /scratch/sw/boost/install-1_44_0-Linux-i686-gcc45/lib/libboost_serialization.so.1.44.0
(gdb) bt
#0  0x001ffec7 in boost::serialization::typeid_system::extended_type_info_typeid_0::is_less_than(boost::serialization::extended_type_info const&) const ()
   from /scratch/sw/boost/install-1_44_0-Linux-i686-gcc45/lib/libboost_serialization.so.1.44.0
#1  0x001ffa9b in boost::serialization::extended_type_info::operator<(boost::serialization::extended_type_info const&) const ()
   from /scratch/sw/boost/install-1_44_0-Linux-i686-gcc45/lib/libboost_serialization.so.1.44.0
#2  0x00205292 in boost::serialization::void_cast_detail::void_caster::operator<(boost::serialization::void_cast_detail::void_caster const&) const ()
   from /scratch/sw/boost/install-1_44_0-Linux-i686-gcc45/lib/libboost_serialization.so.1.44.0
#3  0x00205333 in boost::serialization::void_cast_detail::void_caster::recursive_unregister() const ()
   from /scratch/sw/boost/install-1_44_0-Linux-i686-gcc45/lib/libboost_serialization.so.1.44.0
#4  0x00205ffd in boost::serialization::void_cast_detail::void_caster_shortcut::~void_caster_shortcut() ()
   from /scratch/sw/boost/install-1_44_0-Linux-i686-gcc45/lib/libboost_serialization.so.1.44.0
#5  0x002053be in boost::serialization::void_cast_detail::void_caster::recursive---Type <return> to continue, or q <return> to quit---
_unregister() const ()
   from /scratch/sw/boost/install-1_44_0-Linux-i686-gcc45/lib/libboost_serialization.so.1.44.0
#6  0x001aac6b in boost::serialization::void_cast_detail::void_caster_primitive<A::c1, A::base>::~void_caster_primitive() () from ./lib/libA.so
#7  0x001aaced in boost::serialization::detail::singleton_wrapper<boost::serialization::void_cast_detail::void_caster_primitive<A::c1, A::base> >::~singleton_wrapper() () from ./lib/libA.so
#8  0x00389e14 in __cxa_finalize () from /lib/i386-linux-gnu/libc.so.6
#9  0x001a02b4 in __do_global_dtors_aux () from ./lib/libA.so
#10 0x001adab0 in _fini () from ./lib/libA.so
#11 0x0011ec3d in ?? () from /lib/ld-linux.so.2
#12 0x00389a6f in ?? () from /lib/i386-linux-gnu/libc.so.6
#13 0x00389acf in exit () from /lib/i386-linux-gnu/libc.so.6
#14 0x00370e3f in __libc_start_main () from /lib/i386-linux-gnu/libc.so.6
#15 0x08048b41 in _start ()
<<<

After investigation, I have  checked that this problem disappears when
there is no 'A::d1' class (inherited  from 'A::c1') in the 'A' DLL. Of
course in this  case, we have an *error:  unregistered class - derived
class  not  registered  or  exported* exception  for  'Aprg2.cxx'  and
'Bprg1.cxx'... because the registration  code for class 'A::d1' is not
in 'libA.so' anymore.

So, the problem seems to be related to the 2 level inheritance diagram.
in  DLL A  and  the way  it  should be  addressed  through the  export
mechanism:
 
>>>               
A::base          
|                          
A::c1     
|                         
A::d1           
<<<

Today, I have only one way to fix this in any usage circumstances.  It
consists in  NOT ADDING SERIALIZATION  CODE in DLLs  (removing 'Aio.o'
from 'libA.so' and 'Bio.o'  from 'libB.so') and invoking 'Aio.cpp' and
'Bio.cpp' directly from the main programs. It is not a surprise for it
was the  way I have first  used the library:  serialization code comes
with one single compilation unit.  However, it has counterparts:

- the compiling/build time increases with more and more programs to be
built for all of them  have thus to generate the massively templatized
serialization  code as  we cannot  reuse some  pre-built serialization
code embedded  within the DLLs. For  large projects, it turns  to be a
problem.

- the size  of the executable is  huge for they  instantiate the whole
serialization code for all  classes and archives available, code being
replicated in all executable, which is a kind of waste of space.

- it  enforces the  programmer to  include some  arbitrary 'XXXio.cpp'
files  in  his/her  programs,  and  have some  knowledge  of  the  DLL
internals.  I  would prefer here a more  transparent approach (nothing
special to do would be the best).

Another 'local'  fix is  not to use  at all a  multi-level inheritance
scheme for serializable classes. However this is not acceptable within
the framework of my project(s) and probably other ones.

So, there is something I'm  doing wrong somewhere.  My feeling is that
this use case  with serialization through several DLLs  is almost done
and working.   It seems I only  have to fix  this segfault 'Bprg0.cxx'
issue to  have a valid and  generic solution...  unless  there is some
deeper critical defect in this approach.


BUILD INSTRUCTIONS OF THIS USE CASE:
------------------------------------

To be used under a Linux-like system typically with gcc 4.X and Boost 1.44.
Edit the 'build.sh' script and change the lines:
  BOOST_CFLAGS=$(boost-config --cflags)
  BOOST_LDFLAGS=$(boost-config --ldflags serialization)
to setup the proper Boost/Serialization compile/link flags.

Run the 'build.sh' script to  build the DLLs in the 'lib' subdirectory
and the executable in the current directory.

Run  the 'run.sh'  script  to  run the  executable.  The last  'Bprg0'
segfaults on my system.

You may run  the 'clean.sh' script to remove built  material (do it at
your own risk).

--
F.Mauger <mauger@lpccaen.in2p3.fr>
Update: 2011-06-13