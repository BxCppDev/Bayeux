#!/usr/bin/env bash 
# -*- mode:  shell-script; -*- 
#
# pkgtool 
#
# Note: 
# This script has been generated by the 'pkgtools_create_package' program  
# from the  'pkgtools' package. 
#
# It suits  the use  of some default GNU/makefile generated in  
# the package 'gmk' directory.  
#
# Feel free to modify  this file if you use  
# another system to build/install this package (i.e. Autotools, CMT).
#

APPNAME="pkgtool"

appname=${APPNAME} 
the_base_dir=$(pwd)
the_python_dir=${the_base_dir}/python
the_gmk_dir=${the_base_dir}/gmk
the_pkgtools_dir=${the_base_dir}/pkgtools.d
libpkgtools_sh=${the_pkgtools_dir}/libpkgtools.sh 
if [ ! -f ${libpkgtools_sh} ]; then
    echo " ERROR:$APPNAME: Cannot find '${libpkgtools_sh}' setup file ! Abort !" >&2  
    exit 1
fi
source ${libpkgtools_sh}
export GEOMTOOLS_ROOT=${the_base_dir}

pkgtools__msg_not_using_verbose
pkgtools__msg_not_using_debug
pkgtools__msg_not_using_devel
pkgtools__msg_not_using_date
pkgtools__msg_using_color
pkgtools__ui_not_using_gui

pack_name=geomtools
pack_name_upper=$(pkgtools__to_upper ${pack_name})
pack_name_lower=$(pkgtools__to_lower ${pack_name})
pack_gccver=$(pkgtools__get_gccver)
pack_sys=$(pkgtools__get_sys_with_gccver)
pack_sys=$(pkgtools__get_sys)
pack_config=${pack_name_lower}-config
config_db_file=${the_pkgtools_dir}/.config_db.info
config_sh_file=${the_pkgtools_dir}/.config_db.sh
config_csh_file=${the_pkgtools_dir}/.config_db.csh

# startup scripts:
sh_ss=${pack_name_lower}.sh
csh_ss=${pack_name_lower}.csh
pc_file=${pack_name}.pc
pc_file_skel=${pc_file}.skel

action_mode=""
with_python=0

install__ldflags_mode=""
install__using_cache_files=1

without_python_flag_file=${the_base_dir}/gmk/${pack_name_lower}_without_python.config
	
function my_exit ()
{
    exit $1
}

function print_usage ()
{
    cat <<EOF

  $APPNAME (${pack_name})

  Usage:

    $APPNAME [Options] ACTION [ACTION OPTIONS]

  Options:

    -h 
    --help    : print this help then exit

    -d 
    --debug   : print debug mode informations

    -D 
    --devel   : print devel mode informations

    -v 
    --verbose : verbose print

    -i      
    --interactive  : run in interactive mode (this is the default)

    -b      
    --batch        : run in batch mode (no user interaction)

  Actions:

    list_of_actions : print the list of possible actions

    info       : print package general informations

    configure [OPTIONS] : configure package 
        OPTIONS : 
EOF
    if [ -f ${the_python_dir}/__init__.py ]; then
	cat <<EOF
              --with-python :
                 with Boost Python wrapper module (default)
              --without-python :
                 without Boost Python wrapper module
EOF
    fi
    cat<<EOF
              --with-embedded-boost-io 
              --without-embedded-boost-io (default)
              --skip-all-dependencies-check
              --skip-dependency-check PACKNAME
EOF
    cat <<EOF

    deconfigure : deconfigure package 
  
    build [OPTIONS] [TARGET] : build package
        OPTIONS : 
        TARGET:
           lib (default) : build the shared library
           bin : build all executable programs (if any)
           bin_test : build all executable test programs (if any)
        or the name of a specific program, example:
           test_dummy_${pack_name_lower} : build only the 'test_dummy_${pack_name_lower}'  program

    clean      : clean package

    test       : build test material  

    untest     : remove test material  

    install    : install package
        OPTIONS : 
               --hardcoded-shared-lib-path
               --no-cache-files

    uninstall  : uninstall package

    doc      : generate documentation

    undoc    : remove documentation

    reset    : uninstall, undoc, untest, clean, deconfigure package

   Examples:

    shell> pkgtool --help
    shell> pkgtool info
    shell> pkgtool check
    shell> pkgtool configure
    shell> pkgtool build
    shell> pkgtool build bin
    shell> pkgtool test
    shell> pkgtool install

    shell> pkgtool reset

EOF
}

#######################################################

parse_switch=1
while [ -n "$1" ]; do
    token="$1"
    if [ "${token:0:1}" = "-" ]; then
	opt=${token}
	if [ ${parse_switch} -eq 0 ]; then
	    break
	fi
	if [ "${opt}" = "-h" -o "${opt}" = "--help" ]; then
	    print_usage
	    my_exit 0
	elif [ "${opt}" = "-d" -o "${opt}" = "--debug" ]; then
	    pkgtools__msg_using_debug
	elif [ "${opt}" = "-D" -o "${opt}" = "--devel" ]; then
	    pkgtools__msg_using_devel
	elif [ "${opt}" = "-v" -o "${opt}" = "--verbose" ]; then
	    pkgtools__msg_using_verbose
	elif [ "${opt}" = "-i" -o "${opt}" = "--interactive" ]; then
	    pkgtools__ui_interactive
	elif [ "${opt}" = "-b" -o "${opt}" = "--batch" ]; then
	    pkgtools__ui_batch
	elif [ "${opt}" = "--no-color" ]; then
	    pkgtools__msg_not_using_color
	elif [ "${opt}" = "-G" -o "${opt}" = "--gui" ]; then
	    pkgtools__ui_using_gui
	    pkgtools__msg_devel "Using GUI" 	
	else
	    pkgtools__msg_error "Ignoring option '${opt}' !" 
	    my_exit 1
	fi
    else
	arg=${token}
	parse_switch=0
	if [ "x${action_mode}" = "x" ]; then
	    if [ "$arg" = "configure" ]; then
		action_mode="configure"	
	    elif [ "$arg" = "deconfigure" ]; then
		action_mode="deconfigure"	
	    elif [ "$arg" = "build" ]; then
		action_mode="build"	
	    elif [ "$arg" = "clean" ]; then
		action_mode="clean"	
	    elif [ "$arg" = "install" ]; then
		action_mode="install"	
	    elif [ "$arg" = "uninstall" ]; then
		action_mode="uninstall"	
	    elif [ "$arg" = "info" ]; then
		action_mode="info"	
	    elif [ "$arg" = "check" ]; then
		action_mode="check"	
	    elif [ "$arg" = "doc" ]; then
		action_mode="doc"	
	    elif [ "$arg" = "undoc" ]; then
		action_mode="undoc"	
	    elif [ "$arg" = "test" ]; then
		action_mode="test"	
	    elif [ "$arg" = "untest" ]; then
		action_mode="untest"	
	    elif [ "${arg}" = "reset" ]; then
		action_mode="reset"	
	    elif [ "${arg}" = "list_of_actions" ]; then
		action_mode="list_of_actions"	
	    else
		pkgtools__msg_error "Invalid argument !"
		my_exit 1
	    fi
	else
	    # remaining arguments on command line are kept in "$@"
	    pkgtools__msg_devel "BREAK !"
	    break
	fi
    fi
    shift 1
done

pkgtools__msg_devel "action_mode=${action_mode}"
pkgtools__msg_devel "args=$@"

pkgtools__ui_is_interactive
if [ $? -ne 0 ]; then
    pkgtools__ui_not_using_gui
fi

##########################################################

function do_info ()
{
    __pkgtools__at_function_enter do_info

    pkg_version="undefined"
    pkg_lang="undefined"
    pkg_creation="undefined"
    pkg_authors="undefined"
    pkg_deps="undefined"
    pkg_url="undefined"
    pkg_svn_rep="undefined"
    pkg_desc="undefined"
    if [ -f ./VERSION ]; then
	pkg_version=$(cat ./VERSION)
    fi
    pkg_build="undefined"
    if [ -d ${the_gmk_dir} -a -f ${the_gmk_dir}/GNUmakefile ]; then
	pkg_build="GNU-make"
    fi
    if [ -f ./configure.ac -o -f ./configure.in ]; then
	pkg_build="Autotools"
    fi
    echo "This is package '${pack_name}' (version ${pkg_version})" 
    
    pkgi_file="./pkgtools.d/package.info"
    if [ -f ${pkgi_file} ]; then
	pkg_lang=$(cat ${pkgi_file} | grep "language=" | cut -d= -f2)
	pkg_creation=$(cat ${pkgi_file} | grep "creation=" | cut -d= -f2)
	pkg_authors=$(cat ${pkgi_file} | grep "author=" | cut -d= -f2)
	pkg_deps=$(cat ${pkgi_file} | grep "dependencies=" | cut -d= -f2-)
	pkg_namespace=$(cat ${pkgi_file} | grep "namespace=" | cut -d= -f2)
	pkg_url=$(cat ${pkgi_file} | grep "URL=" | cut -d= -f2)
	pkg_svn_rep=$(cat ${pkgi_file} | grep "SVN base repository=" | cut -d= -f2)
	pkg_desc=$(cat ${pkgi_file} | grep "description=" | cut -d= -f2)
	test -z "${pkg_url}" && pkg_url="no URL"
	test -z "${pkg_desc}" && pkg_desc="no description"
	test -z "${pkg_svn_rep}" && pkg_svn_rep="no SVN repository"
	echo -e "\tName                : ${pack_name}"
	echo -e "\tVersion             : ${pkg_version}"
	echo -e "\tDescription         : ${pkg_desc}"
	echo -e "\tAuthors             : ${pkg_authors}"
	echo -e "\tCreation date       : ${pkg_creation}"
	echo -e "\tLanguage is         : ${pkg_lang}"
	echo -e "\tDependencies are    : ${pkg_deps}"
	if [ "${pkg_lang}" = "C++" ]; then
	    echo -e "\tNamespace           : ${pkg_namespace}"
	fi
	echo -e "\tBuild method        : ${pkg_build}"
	echo -e "\tURL                 : ${pkg_url}"
	echo -e "\tSVN base repository : ${pkg_svn_rep}"
    fi
 
    __pkgtools__at_function_exit
    return 0
}

#######################################################

function check_gmk ()
{
    __pkgtools__at_function_enter check_gmk

    if [ ! -d ${the_gmk_dir} ]; then
	pkgtools__msg_warning "Missing '${the_gmk_dir}' directory !"
	__pkgtools__at_function_exit
	return 1    
    fi

    __pkgtools__at_function_exit
    return 0
}

#######################################################

function do_clean_gmk ()
{
    __pkgtools__at_function_enter do_clean_gmk

    if [ ! -d ${the_gmk_dir} ]; then 
	pkgtools__msg_error "Missing '${the_gmk_dir}' directory !"
	__pkgtools__at_function_exit
	return 1
    fi

    opwd=$(pwd)
    cd ${the_gmk_dir}
    make clean 
    if [ $? -ne 0 ]; then 
	cd ${opwd}
	__pkgtools__at_function_exit
	return 1
    fi

    ### special Python wrapper/program:
    if [ -d ${the_python_dir} ]; then
	cd ${the_python_dir}
	make clean
	if [ $? -ne 0 ]; then 
	    cd ${opwd}
	    __pkgtools__at_function_exit
	    return 1
	fi
    fi
    cd ${the_gmk_dir}

    cd ${opwd}
    __pkgtools__at_function_exit
    return 0
}

function do_build_gmk ()
{
    __pkgtools__at_function_enter do_build_gmk

    pkgtools__msg_info "Build gmk..."
    if [ ! -d ${the_gmk_dir} ]; then 
	pkgtools__msg_error "do_build_gmk: Missing '${the_gmk_dir}' directory !"
	__pkgtools__at_function_exit
	return 1
    fi
    opwd=$(pwd)
    cd ${the_gmk_dir}
    mk_lib=0
    mk_bin=0
    mk_bin_static=0
    pkgtools__msg_devel "Build parameter is '$1'"
    build_tag=""
    if [ -z "$1" ]; then
        build_tag="lib"
    else
        build_tag="$1"
    fi  
    pkgtools__msg_notice "Build target is '${build_tag}'"
    make ${build_tag}
    if [ $? -ne 0 ]; then
	cd ${opwd} 
	pkgtools__msg_error "Build target '${build_tag}' failed !"
	__pkgtools__at_function_exit
	return 1
    fi

    ### special Python wrapper/program:
    if [ -d ${the_python_dir} ]; then
	if [ ! -f ${without_python_flag_file} ]; then
	    cd ${the_python_dir}
	    make
	    if [ $? -ne 0 ]; then
		cd ${opwd} 
		pkgtools__msg_error "Build Python stuff failed !"
		__pkgtools__at_function_exit
		return 1
	    fi
	    cd ${the_gmk_dir}
	fi
    fi
    
    cd ${opwd}
    __pkgtools__at_function_exit
    return 0
}

function do_clean ()
{
    __pkgtools__at_function_enter do_clean

    if [ -d ${the_gmk_dir} ]; then
	do_clean_gmk $@
	__pkgtools__at_function_exit
	return $?
    fi 

    __pkgtools__at_function_exit
    return 1
}

function get_dependency_package_config ()
{  
    __pkgtools__at_function_enter get_dependency_package_config
    dep=$1
    if [ "x${dep}" = "x" ]; then
	__pkgtools__at_function_exit
	return 1
    fi
    dep_cfg=
    dep_lower=$(echo ${dep} | tr 'A-Z' 'a-z')

    if [ "${dep_lower}" == "cernlib" ]; then
	dep_cfg=cernlib
    elif [ "x"${dep_lower} == "mysql" ]; then
	dep_cfg=mysql_config
    else
	dep_cfg=${dep_lower}-config
    fi
    echo ${dep_cfg}

    __pkgtools__at_function_exit
    return 0
}

### This is a default algorithm to check dependencies.
### you may rewrite this function to suit your needs.
function check_dependencies ()
{
    __pkgtools__at_function_enter check_dependencies

    pkgtools__check_dependencies ${the_pkgtools_dir}/package.info $@
    if [ $? -ne 0 ]; then
	pkgtools__msg_warning "Invalid dependency !"
	__pkgtools__at_function_exit
	return 1
    fi

    __pkgtools__at_function_exit
    return 0
}

###################################################################

function do_deconfigure ()
{
    __pkgtools__at_function_enter do_deconfigure

    opwd=$(pwd)
 
    pkgtools__remove_file ${config_db_file}
    pkgtools__remove_file ${config_sh_file}
    pkgtools__remove_file ${config_csh_file}

    cd ${opwd}

    __pkgtools__at_function_exit
    return 0
}

function do_configure ()
{
    __pkgtools__at_function_enter do_configure

    pkgtools__remove_file ${config_db_file}
    pkgtools__remove_file ${config_sh_file}
    pkgtools__remove_file ${config_csh_file}
    echo "# ${pack_name} configuration informations : " >> ${config_db_file}

    prefix=""
    can_python_wrapper=0
    with_python_wrapper=0
    with_ebio=0
    
    if [ -f ${the_python_dir}/__init__.py ]; then
	can_python_wrapper=1
	with_python_wrapper=1
    fi

    skip_all_dependencies_check=0
    skipped_dependencies=
    while [ -n "$1" ]; do
	token="$1"
	    
	if [ "x${token:0:1}" = "x-" ]; then
	    opt=${token}
	    if [ "${opt}" = "-S" -o "${opt}" = "--skip-all-dependencies-check" ]; then
		skip_all_dependencies_check=1
	    elif [ "${opt}" = "-s" -o "${opt}" = "--skip-dependency-check" ]; then
		shift 1
		swpack=$1
		if [ "x${skipped_dependencies}" = "x" ]; then
		    skipped_dependencies=${swpack}
		else
		    skipped_dependencies="${skipped_dependencies} ${swpack}"
		fi
	    elif [ "${opt}" = "--prefix" ]; then
		shift 1
		prefix="$1"
	    elif [ "x${opt}" = "x-ebio" -o "x${opt}" = "x--with-embedded-boost-io" ]; then
		with_ebio=1
	    elif [ "x${opt}" = "x-no-ebio" -o "x${opt}" = "x--without-embedded-boost-io" ]; then
		with_ebio=0
	    elif [ ${can_python_wrapper} -eq 1 ]; then
                # parse Python wrapper switches:
		if [ "x${opt}" = "x--with-python" ]; then
			with_python_wrapper=1
		elif [ "x${opt}" = "x--without-python" ]; then
		    with_python_wrapper=0
		fi
	    else
                # parse other configuration options...
		pkgtools__msg_warning "Ignoring '${opt}' option !"
	    fi
	else
	    arg=${token}
	    pkgtools__msg_warning "Ignoring '${arg}' argument !"
	fi

	shift 1
    done

    if [ "x${prefix}" != "x" ]; then
	pkgtools__msg_warning "Installation prefix is '${prefix}' ! Unsupported option !"
    fi

    # please enter a list of software components you don't want
    # to check:
    # Example: 
    #   skipped_dependencies="gnuplot test dummy"

    if [ ${skip_all_dependencies_check} -eq 0 ]; then
        # Check package dependencies:
	check_dependencies ${skipped_dependencies}
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Dependencies check failed !"
	    __pkgtools__at_function_exit
	    return 1
	fi
    fi

    if [ ${can_python_wrapper} -eq 1 ]; then

	if [ ${with_python_wrapper} -eq 1 ]; then
	    pkgtools__msg_notice "Check Boost.Python avaibility !"
	    which boost-config > /dev/null
	    if [ $? -ne 0 ]; then
		pkgtools__msg_error "Boost is not setup !"
		pkgtools__msg_error "The 'boost_help' package is not setup !"
		__pkgtools__at_function_exit
		return 1
	    fi
	    pkgtools__msg_info "The 'boost_help' package seems ok !"
	    boost_python_check=$(boost-config --librairies | grep python)
	    if [ "x${boost_python_check}" = "x" ]; then
		pkgtools__msg_error "No Boost.Python library !"
		__pkgtools__at_function_exit
		return 1
	    fi
	    pkgtools__msg_notice "Use Python wrapper module from Boost.Python !"
	else
	    pkgtools__msg_warning "Do not use Python wrapper module from Boost.Python !"
	    pkgtools__cfg_store_property ${config_db_file} "${pack_name_upper}_NO_PYTHON" 1
	fi
	
    fi

    if [ ${with_ebio} -ne 0 ]; then
	datatools_with_ebio=$(datatools-config --with-ebio)
	if [ ${datatools_with_ebio} -eq 0 ]; then
	    pkgtools__msg_warning "As datatools has no Embedded Boost I/O support, geomtools won't too !"
	    with_ebio=0
	else
	    pkgtools__msg_warning "Embedded pre-built Boost/Serialization code !"	
	fi
    fi
    if [ ${with_ebio} -eq 0 ]; then
	pkgtools__msg_warning "${pack_name} will not embed pre-built Boost/Serialization code !"	
	pkgtools__cfg_store_property ${config_db_file} "${pack_name_upper}_NO_EBIO" 1
    fi

    echo "# end of ${pack_name} configuration informations."          >> ${config_db_file} 
    cat ${config_db_file} | ${the_pkgtools_dir}/config_to_setup.py sh  > ${config_sh_file}
    cat ${config_db_file} | ${the_pkgtools_dir}/config_to_setup.py csh > ${config_csh_file}

    __pkgtools__at_function_exit
    return 0
}

function do_build ()
{
    __pkgtools__at_function_enter do_build

    if [ ! -f ${config_sh_file} ]; then
	pkgtools__msg_error "Missing '${config_sh_file}' file ! Please first configure !"
	__pkgtools__at_function_exit
	return 1	
    fi
    source ${config_sh_file}

    if [ -d ${the_gmk_dir} ]; then
	if [ -d ${the_python_dir} ]; then
	    if [ -f ${without_python_flag_file} ]; then
		source ${without_python_flag_file}
	    fi
	fi
	if [ "x$@" = "x" ]; then
	    do_build_gmk lib
	    if [ $? -ne 0 ]; then
		__pkgtools__at_function_exit
		return 1
	    fi
	    do_build_gmk bin
	    if [ $? -ne 0 ]; then
		__pkgtools__at_function_exit
		return 1
	    fi
	else
	    do_build_gmk $@
	    if [ $? -ne 0 ]; then
		__pkgtools__at_function_exit
		return 1
	    fi
	fi
	# do_build_gmk $@
	# local code=$?
	# __pkgtools__at_function_exit
	# return ${code}
    fi

    __pkgtools__at_function_exit
    return 0
}

function do_startup ()
{
    __pkgtools__at_function_enter do_startup

    pkgtools__msg_warning "SH startup = ${the_base_dir}/${sh_ss}"
    cat ${the_pkgtools_dir}/package.sh.skel | sed -e "s@__PACKAGE_ROOT__@${GEOMTOOLS_ROOT}@g" -e "s@__PACKAGE_NAME__@${pack_name_upper}@g" -e "s@__Package_name__@${pack_name}@g" > ${the_base_dir}/${sh_ss} 

  
    
    pkgtools__msg_warning "CSH startup = ${the_base_dir}/${csh_ss}"
    cat ${the_pkgtools_dir}/package.csh.skel | sed -e "s@__PACKAGE_ROOT__@${GEOMTOOLS_ROOT}@g" -e "s@__PACKAGE_NAME__@${pack_name_upper}@g" -e "s@__Package_name__@${pack_name}@g" > ${the_base_dir}/${csh_ss}

    ### using hardcoded shared lib path within LDFLAGS:
    if [ "X${install__ldflags_mode}" = "Xhardcoded_shared_lib_path" ]; then
	cat >> ${the_base_dir}/${sh_ss} <<EOF
export ${pack_name_upper}_LDFLAGS_MODE="${install__ldflags_mode}"

EOF
	cat >> ${the_base_dir}/${csh_ss} <<EOF
setenv ${pack_name_upper}_LDFLAGS_MODE "${install__ldflags_mode}"

EOF
    else
	cat >> ${the_base_dir}/${sh_ss} <<EOF
#export ${pack_name_upper}_LDFLAGS_MODE="hardcoded_shared_lib_path"

EOF
	cat >> ${the_base_dir}/${csh_ss} <<EOF
#setenv ${pack_name_upper}_LDFLAGS_MODE "hardcoded_shared_lib_path"

EOF
    fi

    ### using cflags/ldflags cache files:
    if [ ${install__using_cache_files} -eq 0 ]; then
	cat >> ${the_base_dir}/${sh_ss} <<EOF
export ${pack_name_upper}_USING_CACHE_FILES=0

EOF
	cat >> ${the_base_dir}/${csh_ss} <<EOF
setenv ${pack_name_upper}_USING_CACHE_FILES 0

EOF
    else
	cat >> ${the_base_dir}/${sh_ss} <<EOF
#export ${pack_name_upper}_USING_CACHE_FILES=0

EOF
	cat >> ${the_base_dir}/${csh_ss} <<EOF
#setenv ${pack_name_upper}_USING_CACHE_FILES 0

EOF
    fi

    cat ${config_sh_file}  >> ${the_base_dir}/${sh_ss}
    cat ${config_csh_file} >> ${the_base_dir}/${csh_ss}

    cat<<EOF

Setup scripts:

  '${the_base_dir}/${sh_ss}' for sh-shells

and  

  '${the_base_dir}/${csh_ss}' for csh-shells

have been generated.

You may source these scripts at startup time 
(i.e. from your '~/.bashrc' or '~/.(t)cshrc' files).

EOF

    __pkgtools__at_function_exit
    return 0
}


function do_pkg_config_pc ()
{
    __pkgtools__at_function_enter do_pkg_config_pc

    if [ -f ./pkgtools.d/${pc_file_skel} ]; then
	cat ./pkgtools.d/${pc_file_skel} | \
	    sed -e "s@__PACKAGE_ROOT__@${the_base_dir}@g" \
	    -e "s@__PACKAGE_SYS__@${pack_sys}@g" \
	    > ${the_base_dir}/${pack_sys}/${pc_file}
    fi

    __pkgtools__at_function_exit
    return 0
}


function kill_startup ()
{
    __pkgtools__at_function_enter kill_startup

    test -f ${the_base_dir}/${sh_ss} && rm -f  ${the_base_dir}/${sh_ss} || echo -n ""
    test -f ${the_base_dir}/${csh_ss} && rm -f  ${the_base_dir}/${csh_ss} || echo -n ""

    cat<<EOF
Don't forget to remove environment variables in your startup scripts.
Particularly, you should not source the following scripts anymore
from your '~/.bashrc' or '~/.(t)cshrc' files:

  '${the_base_dir}/${sh_ss}' for sh-shells

and  

  '${the_base_dir}/${csh_ss}' for csh-shells

EOF
    __pkgtools__at_function_exit
    return 0
}

##########################################################

function do_install ()
{
    __pkgtools__at_function_enter do_install

    if [ ! -f ${config_sh_file} ]; then
	pkgtools__msg_error "Missing '${config_sh_file}' file ! Please first configure and build !"
	__pkgtools__at_function_exit
	return 1	
    fi
    source ${config_sh_file}

    # reset default install options:
    install__ldflags_mode=""
    install__using_cache_files=1
    dummy=0

    while [ -n "$1" ]; do
	token="$1"
	if [ "x${token:0:1}" = "x-" ]; then
	    opt=${token}
	    if [ "${opt}" = "--dummy" ]; then
		dummy=1
	    elif [ "${opt}" = "--hardcoded-shared-lib-path" ]; then
		install__ldflags_mode="hardcoded_shared_lib_path"
	    elif [ "${opt}" = "--no-cache-files" ]; then
		install__using_cache_files=0
	    else
                # parse other configuration options...
		pkgtools__msg_warning "Ignoring '${opt}' option !"
	    fi
	else
	    arg=${token}
	    pkgtools__msg_warning "Ignoring '${arg}' argument !"
	fi

	shift 1
    done

    pkgtools__msg_info "Install package '${pack_name}'..."
    opwd=$(pwd)
    cd ${the_gmk_dir}
    make install 
    if [ $? -ne 0 ]; then 
	pkgtools__msg_error "make install failed !"
	cd ${opwd}
	return 1
    fi

    ### special Python wrapper/program:
    if [ -d ${the_python_dir} ]; then
	if [ ! -f ${without_python_flag_file} ]; then
	    cd ${the_python_dir}
	    make install
	    cd ${the_gmk_dir}
	fi
    fi
    ###

    cd ${opwd}
    #do_pkg_config_pc
    pkgtools__msg_debug "do_startup..."
    do_startup
    pkgtools__msg_debug "ok"

    local sysdir=${the_base_dir}/$(pkgtools__get_sys)
    test -L ${sysdir}/bin/${pack_config} && rm -f ${sysdir}/bin/${pack_config} 
    ln -s -f ${the_pkgtools_dir}/${pack_config} ${sysdir}/bin/${pack_config}

    __pkgtools__at_function_exit
    return 0
}

function do_uninstall ()
{
    __pkgtools__at_function_enter do_uninstall

    pkgtools__msg_info "Uninstall package '${pack_name}'..."
    opwd=$(pwd)
    cd ${the_gmk_dir}
    make uninstall 
    if [ $? -ne 0 ]; then 
	cd ${opwd}
	__pkgtools__at_function_exit
	return 1
    fi

    ### special Python wrapper/program:
    if [ -d ${the_python_dir} ]; then
	cd ${the_python_dir}
	make uninstall
	cd ${the_gmk_dir}
    fi

    cd ${opwd}
    kill_startup

    local sysdir=${the_base_dir}/$(pkgtools__get_sys)
    test -L ${sysdir}/bin/${pack_config} && rm -f ${sysdir}/bin/${pack_config} 

    if [ -f ${the_base_dir}/.cflags.cache ]; then
	rm -f  ${the_base_dir}/.cflags.cache
    fi

    if [ -f ${the_base_dir}/.ldflags.cache ]; then
	rm -f  ${the_base_dir}/.ldflags.cache
    fi

    __pkgtools__at_function_exit
    return 0
}

function do_check ()
{
    __pkgtools__at_function_enter do_check

    can_python_wrapper=0
    with_python_wrapper=0
    if [ -f ${the_python_dir}/__init__.py ]; then
	can_python_wrapper=1
	with_python_wrapper=1
    fi

    skip_all_dependencies_check=0
    skipped_dependencies=
    while [ -n "$1" ]; do
	token="$1"
	    
	if [ "x${token:0:1}" = "x-" ]; then
	    opt=${token}
	    if [ "${opt}" = "-S" -o "${opt}" = "--skip-all-dependencies-check" ]; then
		skip_all_dependencies_check=1
	    elif [ "${opt}" = "-s" -o "${opt}" = "--skip-dependency-check" ]; then
		shift 1
		swpack=$1
		pkgtools__msg_debug "swpack = '${swpack}'"
		if [ "x${skipped_dependencies}" = "x" ]; then
		    skipped_dependencies=${swpack}
		else
		    skipped_dependencies="${skipped_dependencies} ${swpack}"
		fi
	    elif [ ${can_python_wrapper} -eq 1 ]; then
                # parse Python wrapper switches:
		if [ "x${opt}" = "x--with-python" ]; then
			with_python_wrapper=1
		elif [ "x${opt}" = "x--without-python" ]; then
		    with_python_wrapper=0
		fi
	    elif [ "${opt}" = "--prefix" ]; then
		shift 1
		prefix="$1"
	    else
                # parse other configuration options...
		pkgtools__msg_warning "Ignoring '${opt}' option !"
	    fi
	else
	    arg=${token}
	    pkgtools__msg_warning "Ignoring '${arg}' argument !"
	fi

	shift 1
    done

    pkgtools__msg_debug "skipped_dependencies = '${skipped_dependencies}'"

    ok=1
    if [ ${can_python_wrapper} -eq 1 ]; then

	if [ ${with_python_wrapper} -eq 1 ]; then
	    pkgtools__msg_notice "Check Boost.Python avaibility !"
	    which boost-config > /dev/null
	    if [ $? -ne 0 ]; then
		pkgtools__msg_error "Boost is not setup !"
		pkgtools__msg_error "The 'boost_help' package is not setup !"
		ok=0
		#__pkgtools__at_function_exit
		#return 1
	    fi
	    pkgtools__msg_info "The 'boost_help' package seems ok !"
	    boost_python_check=$(boost-config --librairies | grep python)
	    if [ "x${boost_python_check}" = "x" ]; then
		pkgtools__msg_error "No Boost.Python library !"
		ok=0
		#__pkgtools__at_function_exit
		#return 1
	    fi
	    pkgtools__msg_notice "Python wrapper module from Boost.Python is usable  !"
	else
	    pkgtools__msg_error "Python wrapper module from Boost.Python is not usable !"
	fi
 
    fi
 
    if [ ${skip_all_dependencies_check} -eq 0 ]; then
        # Check package dependencies:
	check_dependencies ${skipped_dependencies}
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Dependencies check failed !"
	    __pkgtools__at_function_exit
	    return 1
	fi
    else
	pkgtools__msg_warning "No dependency check !"
    fi

    __pkgtools__at_function_exit
    return 0
}

##########################################################

function do_test ()
{
    __pkgtools__at_function_enter do_test

    if [ -d ${the_gmk_dir} ]; then
	if [ -d ${the_python_dir} ]; then
	    if [ -f ${without_python_flag_file} ]; then
		source ${without_python_flag_file}
	    fi
	fi
	do_build_gmk bin_test
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Build test program failed !"
	    __pkgtools__at_function_exit
	    return 1
	fi
    fi

    test_prog=test_dummy_${pack_name_lower}
    if [ -f ./programs/${test_prog}.cxx ]; then
	LD_LIBRARY_PATH=$(pkgtools__get_sys)/lib:${LD_LIBRARY_PATH} ./$(pkgtools__get_sys)/bin/${test_prog} 
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Test program '${test_prog}' failure !"
	    __pkgtools__at_function_exit
	    return 1
	else
	    pkgtools__msg_notice "Test program '${test_prog}' success !"
	fi
    fi

    __pkgtools__at_function_exit
    return 0
}

function do_untest ()
{
    __pkgtools__at_function_enter do_untest

    if [ -d ${the_gmk_dir} ]; then
	do_clean_gmk clean_bin_test
    fi

    pkgtools__msg_notice "Removing test files..."
    pkgtools_remove_file test_utils.txt 
    pkgtools_remove_file test_utils2.txt 
    pkgtools_remove_file test_box.data 
    pkgtools_remove_file test_cylinder.data 
    pkgtools_remove_file test_intersection_3d.data 
    pkgtools_remove_file test_things.xml 
    pkgtools_remove_file test_utils2.txt 
    pkgtools_remove_file test_utils_3d.txt 
    pkgtools_remove_file test_utils_gid.txt 
    pkgtools_remove_file test_utils.txt 

    __pkgtools__at_function_exit
    return 0
}

##########################################################

function do_doc ()
{ 
    __pkgtools__at_function_enter do_doc

    pkgtools__msg_info "Generate documentation for package '${pack_name}'..."

    which doxygen >/dev/null 2>&1
    if [ $? -ne 0 ]; then
	pkgtools__msg_error "Cannot find doxygen ! Cannot generate documentation !"
	__pkgtools__at_function_exit
        return 1
    fi
    if [ ! -f ${the_base_dir}/pkgtools.d/${pack_name}.doxygen ]; then
	pkgtools__msg_error "Missing '${the_base_dir}/pkgtools.d/${pack_name}.doxygen' configuration file !"
	__pkgtools__at_function_exit
       return 1
    fi
    # doxygen -g ${the_base_dir}/pkgtools.d/${pack_name}.doxygen
    doxygen ${the_base_dir}/pkgtools.d/${pack_name}.doxygen 

    pkgtools__msg_notice "Doxygen documentation is at: ${the_base_dir}/doc/doxygen/html/index.html"
    pkgtools__msg_notice "Please run: 'firefox file://$(pwd)/doc/doxygen/html/index.html &' or something similar..."

    __pkgtools__at_function_exit
    return 0
}

function do_undoc ()
{
    __pkgtools__at_function_enter do_undoc
    opwd=$(pwd)

    if [ -d ${the_base_dir}/doc/doxygen ]; then
	rm -fr ${the_base_dir}/doc/doxygen
    fi

    cd ${opwd}
    __pkgtools__at_function_exit
    return 0
}

##########################################################

function do_reset ()
{
    __pkgtools__at_function_enter do_reset

    pkgtools_remove_file ${the_base_dir}/.cflags.cache
    pkgtools_remove_file ${the_base_dir}/.ldflags.cache

    do_undoc
    do_untest
    do_uninstall
    do_clean
    do_deconfigure

    __pkgtools__at_function_exit
    return 0
}

##########################################################

function main ()
{
    __pkgtools__at_function_enter main
    
    # Some checks...
    if [ -z "${action_mode}" ]; then
	pkgtools__msg_error "Missing action !"
	print_usage
	__pkgtools__at_function_exit
	return 1
    fi

    if [ ! -d ./pkgtools.d ]; then
	pkgtools__msg_error "Please run the 'pkgtools.d/pkgtool' utility from the base package directory !"
	__pkgtools__at_function_exit
	return 1
    fi

    pkgtools__msg_debug "Base package directory is '${the_base_dir}' !"
    
    check_gmk
    if [ $? -ne 0 ]; then
	pkgtools__msg_error "Missing gmk directory ! Abort !"
	__pkgtools__at_function_exit
	return 1
    fi
    
    # Perform action...
    
    if [ "${action_mode}" = "info" ]; then
	do_info $@
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Print info failed !"
	    __pkgtools__at_function_exit
	    return 1
	fi
    fi
    
    if [ "${action_mode}" = "check" ]; then
	do_check $@
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Package check failed !"
	    __pkgtools__at_function_exit
	    return 1
	fi
    fi

    if [ "${action_mode}" = "configure" ]; then
	do_configure $@
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Package configuration failed !"
	    __pkgtools__at_function_exit
	    return 1
	fi
    fi
    
    if [ "${action_mode}" = "deconfigure" ]; then
	do_deconfigure $@
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Package de-configuration failed !"
	    __pkgtools__at_function_exit
	    return 1
	fi
    fi
    
    if [ "${action_mode}" = "build" ]; then
	do_build $@
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "  building failed !"
	    __pkgtools__at_function_exit
	    return 1
	fi
    fi
    
    if [ "${action_mode}" = "clean" ]; then
	do_clean $@
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Package cleaning failed !"
	    __pkgtools__at_function_exit
	    return 1
	fi
    fi
    
    if [ "${action_mode}" = "install" ]; then
	do_install $@
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Installation failed !"
	    __pkgtools__at_function_exit
	    return 1
	fi
    fi
    
    if [ "${action_mode}" = "uninstall" ]; then
	do_uninstall $@
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Uninstallation failed !"
	    __pkgtools__at_function_exit
	    return 1
	fi
    fi
    
    if [ "${action_mode}" = "doc" ]; then
	do_doc $@
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Documentation generation failed !"
	    __pkgtools__at_function_exit
	    return 1
	fi
    fi

    if [ "${action_mode}" = "undoc" ]; then
	do_undoc
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Documentation removal failed!"
	    __pkgtools__at_function_exit
	    return 1
	fi
    fi

    if [ "${action_mode}" = "test" ]; then
	do_test
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Test material failed!"
	    return 1
	fi
    fi

    if [ "${action_mode}" = "untest" ]; then
	do_untest
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "Test material removal failed!"
	    return 1
	fi
    fi

    if [ "${action_mode}" = "reset" ]; then
	do_reset
	if [ $? -ne 0 ]; then
	    pkgtools__msg_error "reset failed!"
	    __pkgtools__at_function_exit
	    return 1
	fi
    fi

    if [ "${action_mode}" = "list_of_actions" ]; then
	echo "list_of_actions info check configure deconfigure build clean install uninstall doc undoc test untest reset" 
	__pkgtools__at_function_exit
	return 0
    fi

    __pkgtools__at_function_exit
    return 0
}

##########################################################

main $@
if [ $? -ne 0 ]; then
    my_exit 1
fi
my_exit 0

# end of pkgtool
