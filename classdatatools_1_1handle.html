<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bayeux: datatools::handle&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_bayeux_66x55_transparent.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Bayeux
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">Core Foundation library for SuperNEMO</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedatatools.html">datatools</a></li><li class="navelem"><a class="el" href="classdatatools_1_1handle.html">handle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classdatatools_1_1handle-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">datatools::handle&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Templatized handle class that wraps a Boost shared pointer and behaves like a reference.  
 <a href="classdatatools_1_1handle.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="handle_8h_source.html">bayeux/datatools/handle.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a34095d19be42d3b60389df23fd264854"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatatools_1_1handle.html#a34095d19be42d3b60389df23fd264854">value_type</a></td></tr>
<tr class="separator:a34095d19be42d3b60389df23fd264854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131d6e24e473f1f3e5bf2ee15d19c738"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classdatatools_1_1handle.html#a34095d19be42d3b60389df23fd264854">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatatools_1_1handle.html#a131d6e24e473f1f3e5bf2ee15d19c738">reference_type</a></td></tr>
<tr class="separator:a131d6e24e473f1f3e5bf2ee15d19c738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd201340189fd2375adb0ef44f95b68"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structdatatools_1_1handle__predicate.html">handle_predicate</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatatools_1_1handle.html#a3fd201340189fd2375adb0ef44f95b68">predicate_type</a></td></tr>
<tr class="separator:a3fd201340189fd2375adb0ef44f95b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abfb36de1077ca1d6fb3ec87aaecc8819"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatatools_1_1handle.html#abfb36de1077ca1d6fb3ec87aaecc8819">handle</a> (T *held=nullptr)</td></tr>
<tr class="memdesc:abfb36de1077ca1d6fb3ec87aaecc8819"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor.  <a href="#abfb36de1077ca1d6fb3ec87aaecc8819">More...</a><br /></td></tr>
<tr class="separator:abfb36de1077ca1d6fb3ec87aaecc8819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576c0af5a85f196fe72f38bbb6afa6cc"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename  = std::enable_if&lt;               std::is_same&lt;const Q, T&gt;::value &amp;&amp;               std::is_const&lt;T&gt;::value &amp;&amp;               !std::is_const&lt;Q&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a576c0af5a85f196fe72f38bbb6afa6cc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatatools_1_1handle.html#a576c0af5a85f196fe72f38bbb6afa6cc">handle</a> (Q *held=nullptr)</td></tr>
<tr class="memdesc:a576c0af5a85f196fe72f38bbb6afa6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constructor from a pointer to some on-the-fly allocated instance.  <a href="#a576c0af5a85f196fe72f38bbb6afa6cc">More...</a><br /></td></tr>
<tr class="separator:a576c0af5a85f196fe72f38bbb6afa6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2d3c64cb74cfe0c8fbb5d507a5f825"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatatools_1_1handle.html#a1b2d3c64cb74cfe0c8fbb5d507a5f825">handle</a> (<a class="el" href="namespacedatatools.html#a8a63304aa8648ed4de282e39ea77e58f">const</a> boost::shared_ptr&lt; T &gt; &amp;sp)</td></tr>
<tr class="memdesc:a1b2d3c64cb74cfe0c8fbb5d507a5f825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor on a boost shared_ptr.  <a href="#a1b2d3c64cb74cfe0c8fbb5d507a5f825">More...</a><br /></td></tr>
<tr class="separator:a1b2d3c64cb74cfe0c8fbb5d507a5f825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c098e52b2b05cb14833b107d9c2bc24"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatatools_1_1handle.html#a2c098e52b2b05cb14833b107d9c2bc24">~handle</a> ()</td></tr>
<tr class="memdesc:a2c098e52b2b05cb14833b107d9c2bc24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a2c098e52b2b05cb14833b107d9c2bc24">More...</a><br /></td></tr>
<tr class="separator:a2c098e52b2b05cb14833b107d9c2bc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae954b63fafda6dcaa4f4928fbf78d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatatools_1_1handle.html#a3ae954b63fafda6dcaa4f4928fbf78d2">unique</a> () <a class="el" href="namespacedatatools.html#a8a63304aa8648ed4de282e39ea77e58f">const</a></td></tr>
<tr class="memdesc:a3ae954b63fafda6dcaa4f4928fbf78d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the current handle holds an uniquely referenced object.  <a href="#a3ae954b63fafda6dcaa4f4928fbf78d2">More...</a><br /></td></tr>
<tr class="separator:a3ae954b63fafda6dcaa4f4928fbf78d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19dd12122dedfc2bafdb7c50c283ec4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatatools_1_1handle.html#a19dd12122dedfc2bafdb7c50c283ec4e">has_data</a> () <a class="el" href="namespacedatatools.html#a8a63304aa8648ed4de282e39ea77e58f">const</a></td></tr>
<tr class="memdesc:a19dd12122dedfc2bafdb7c50c283ec4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the internal shared pointer holds something.  <a href="#a19dd12122dedfc2bafdb7c50c283ec4e">More...</a><br /></td></tr>
<tr class="separator:a19dd12122dedfc2bafdb7c50c283ec4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b333dd6309b1389acb6d3c6c604881"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatatools_1_1handle.html#a08b333dd6309b1389acb6d3c6c604881">operator bool</a> () <a class="el" href="namespacedatatools.html#a8a63304aa8648ed4de282e39ea77e58f">const</a></td></tr>
<tr class="memdesc:a08b333dd6309b1389acb6d3c6c604881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the internal shared pointer holds something.  <a href="#a08b333dd6309b1389acb6d3c6c604881">More...</a><br /></td></tr>
<tr class="separator:a08b333dd6309b1389acb6d3c6c604881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6862b0b7da8dec2bd40426944ba04212"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatatools_1_1handle.html#a6862b0b7da8dec2bd40426944ba04212">swap</a> (<a class="el" href="classdatatools_1_1handle.html">handle</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="separator:a6862b0b7da8dec2bd40426944ba04212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d19c9e73b1d5fcf1363141373869414"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedatatools.html#a8a63304aa8648ed4de282e39ea77e58f">const</a> T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatatools_1_1handle.html#a0d19c9e73b1d5fcf1363141373869414">get</a> () <a class="el" href="namespacedatatools.html#a8a63304aa8648ed4de282e39ea77e58f">const</a></td></tr>
<tr class="memdesc:a0d19c9e73b1d5fcf1363141373869414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the hosted instance.  <a href="#a0d19c9e73b1d5fcf1363141373869414">More...</a><br /></td></tr>
<tr class="separator:a0d19c9e73b1d5fcf1363141373869414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a1d8afcae062d8305f1c8f912acb8b"><td class="memTemplParams" colspan="2">template&lt;typename Q  = T&gt; </td></tr>
<tr class="memitem:a03a1d8afcae062d8305f1c8f912acb8b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; Q, T &gt;::value &amp;&amp;!std::is_const&lt; Q &gt;::value &amp;&amp;!std::is_const&lt; T &gt;::value, Q &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatatools_1_1handle.html#a03a1d8afcae062d8305f1c8f912acb8b">grab</a> ()</td></tr>
<tr class="memdesc:a03a1d8afcae062d8305f1c8f912acb8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a non-const reference to the hosted instance.  <a href="#a03a1d8afcae062d8305f1c8f912acb8b">More...</a><br /></td></tr>
<tr class="separator:a03a1d8afcae062d8305f1c8f912acb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c79b193efb3f1e434e355fec0772bc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatatools_1_1handle.html#a3c79b193efb3f1e434e355fec0772bc5">reset</a> (T *elem=nullptr)</td></tr>
<tr class="memdesc:a3c79b193efb3f1e434e355fec0772bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the internal shared pointer with a new instance.  <a href="#a3c79b193efb3f1e434e355fec0772bc5">More...</a><br /></td></tr>
<tr class="separator:a3c79b193efb3f1e434e355fec0772bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98421be32960e88d3c97631eeced9c59"><td class="memTemplParams" colspan="2">template&lt;typename Q  = T&gt; </td></tr>
<tr class="memitem:a98421be32960e88d3c97631eeced9c59"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; Q, T &gt;::value &amp;&amp;!std::is_const&lt; Q &gt;::value &amp;&amp;!std::is_const&lt; T &gt;::value, <a class="el" href="classdatatools_1_1handle.html">handle</a>&lt; <a class="el" href="namespacedatatools.html#a8a63304aa8648ed4de282e39ea77e58f">const</a> Q &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdatatools_1_1handle.html#a98421be32960e88d3c97631eeced9c59">to_const</a> () <a class="el" href="namespacedatatools.html#a8a63304aa8648ed4de282e39ea77e58f">const</a></td></tr>
<tr class="memdesc:a98421be32960e88d3c97631eeced9c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a handle instance that hosts the const instance.  <a href="#a98421be32960e88d3c97631eeced9c59">More...</a><br /></td></tr>
<tr class="separator:a98421be32960e88d3c97631eeced9c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac98d07dd8f7b70e16ccb9a01abf56b9c"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdatatools_1_1handle.html#ac98d07dd8f7b70e16ccb9a01abf56b9c">boost::serialization::access</a></td></tr>
<tr class="separator:ac98d07dd8f7b70e16ccb9a01abf56b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class datatools::handle&lt; T &gt;</h3>

<p>Templatized handle class that wraps a Boost shared pointer and behaves like a reference. </p>
<p>A handle object is given the responsability to handle a class instance through its pointer using the shared pointer mechanism from Boost. The inner hidden pointer can be null. It must be initialized with the 'new' construction operator. The handle class is copyable and can be used within STL containers.</p>
<p><b>Example:</b> </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;datatools/handle.h&gt;</span></div><div class="line"></div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedatatools.html">datatools</a>;</div><div class="line">  <a class="code" href="classdatatools_1_1handle.html">handle&lt;int&gt;</a> h0;  <span class="comment">// a default int is allocated</span></div><div class="line">  h0.<a class="code" href="classdatatools_1_1handle.html#a03a1d8afcae062d8305f1c8f912acb8b">grab</a> () = 999; <span class="comment">// access the int and modify its value</span></div><div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;h0 = &quot;</span> &lt;&lt; h0.<a class="code" href="classdatatools_1_1handle.html#a0d19c9e73b1d5fcf1363141373869414">get</a> () &lt;&lt; endl; <span class="comment">// print it</span></div><div class="line">  h0.<a class="code" href="classdatatools_1_1handle.html#a3c79b193efb3f1e434e355fec0772bc5">reset</a> (<span class="keyword">new</span> <span class="keywordtype">int</span> (0)); <span class="comment">// discard the former int</span></div><div class="line">                          <span class="comment">// and allocate a new one</span></div><div class="line">  <a class="code" href="classdatatools_1_1handle.html">handle&lt;int&gt;</a> h1 (<span class="keyword">new</span> <span class="keywordtype">int</span> (1)); <span class="comment">// create a new handle for another int</span></div><div class="line">  {</div><div class="line">    <a class="code" href="classdatatools_1_1handle.html">handle&lt;int&gt;</a> h2 (h1); <span class="comment">// another handle that shares the same int</span></div><div class="line">                         <span class="comment">// than the previous handle</span></div><div class="line">    h2.grab () = 666;     <span class="comment">//change the int value through this handle</span></div><div class="line">  }</div><div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;h1 = &quot;</span> &lt;&lt; h1.get () &lt;&lt; endl; <span class="comment">// print it through the</span></div><div class="line">                                        <span class="comment">// first handle</span></div><div class="line">};</div></div><!-- fragment --> </div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3fd201340189fd2375adb0ef44f95b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd201340189fd2375adb0ef44f95b68">&#9670;&nbsp;</a></span>predicate_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structdatatools_1_1handle__predicate.html">handle_predicate</a>&lt;T&gt; <a class="el" href="classdatatools_1_1handle.html">datatools::handle</a>&lt; T &gt;::<a class="el" href="classdatatools_1_1handle.html#a3fd201340189fd2375adb0ef44f95b68">predicate_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a131d6e24e473f1f3e5bf2ee15d19c738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a131d6e24e473f1f3e5bf2ee15d19c738">&#9670;&nbsp;</a></span>reference_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classdatatools_1_1handle.html#a34095d19be42d3b60389df23fd264854">value_type</a>&amp; <a class="el" href="classdatatools_1_1handle.html">datatools::handle</a>&lt; T &gt;::<a class="el" href="classdatatools_1_1handle.html#a131d6e24e473f1f3e5bf2ee15d19c738">reference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34095d19be42d3b60389df23fd264854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34095d19be42d3b60389df23fd264854">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classdatatools_1_1handle.html">datatools::handle</a>&lt; T &gt;::<a class="el" href="classdatatools_1_1handle.html#a34095d19be42d3b60389df23fd264854">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abfb36de1077ca1d6fb3ec87aaecc8819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb36de1077ca1d6fb3ec87aaecc8819">&#9670;&nbsp;</a></span>handle() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdatatools_1_1handle.html">datatools::handle</a>&lt; T &gt;::<a class="el" href="classdatatools_1_1handle.html">handle</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>held</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default constructor. </p>
<p>The default constructor automatically allocate an object handled by the internal shared pointer.A constructor from a pointer to some on-the-fly allocated instance.</p>
<p>This constructor is given a pointer to some dynamically allocated instance and pass it to the internal shared pointer.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classdatatools_1_1handle.html">datatools::handle&lt;int&gt;</a> h(<span class="keyword">new</span> <span class="keywordtype">int</span>(3));</div></div><!-- fragment --><p> or </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> * pi = <span class="keyword">new</span> int(3);</div><div class="line"><a class="code" href="classdatatools_1_1handle.html">datatools::handle&lt;int&gt;</a> h(pi);</div></div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>Never use such kind of mechanism to initialize a handle: <div class="fragment"><div class="line"><span class="keywordtype">int</span> i = 3;</div><div class="line"><a class="code" href="classdatatools_1_1handle.html">datatools::handle&lt;int&gt;</a> h(&amp;i);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a576c0af5a85f196fe72f38bbb6afa6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576c0af5a85f196fe72f38bbb6afa6cc">&#9670;&nbsp;</a></span>handle() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename  = std::enable_if&lt;               std::is_same&lt;const Q, T&gt;::value &amp;&amp;               std::is_const&lt;T&gt;::value &amp;&amp;               !std::is_const&lt;Q&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdatatools_1_1handle.html">datatools::handle</a>&lt; T &gt;::<a class="el" href="classdatatools_1_1handle.html">handle</a> </td>
          <td>(</td>
          <td class="paramtype">Q *&#160;</td>
          <td class="paramname"><em>held</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A constructor from a pointer to some on-the-fly allocated instance. </p>
<p>This constructor is given a pointer to some dynamically allocated instance and pass it to the internal shared const pointer. This means that the handle does not allow to modify the element it handles.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classdatatools_1_1handle.html">datatools::handle&lt;const int&gt;</a> h(<span class="keyword">new</span> <span class="keywordtype">int</span>(3));</div></div><!-- fragment --> 
</div>
</div>
<a id="a1b2d3c64cb74cfe0c8fbb5d507a5f825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2d3c64cb74cfe0c8fbb5d507a5f825">&#9670;&nbsp;</a></span>handle() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdatatools_1_1handle.html">datatools::handle</a>&lt; T &gt;::<a class="el" href="classdatatools_1_1handle.html">handle</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedatatools.html#a8a63304aa8648ed4de282e39ea77e58f">const</a> boost::shared_ptr&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor on a boost shared_ptr. </p>

</div>
</div>
<a id="a2c098e52b2b05cb14833b107d9c2bc24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c098e52b2b05cb14833b107d9c2bc24">&#9670;&nbsp;</a></span>~handle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classdatatools_1_1handle.html">datatools::handle</a>&lt; T &gt;::~<a class="el" href="classdatatools_1_1handle.html">handle</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0d19c9e73b1d5fcf1363141373869414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d19c9e73b1d5fcf1363141373869414">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedatatools.html#a8a63304aa8648ed4de282e39ea77e58f">const</a> T&amp; <a class="el" href="classdatatools_1_1handle.html">datatools::handle</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to the hosted instance. </p>

</div>
</div>
<a id="a03a1d8afcae062d8305f1c8f912acb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a1d8afcae062d8305f1c8f912acb8b">&#9670;&nbsp;</a></span>grab()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Q  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;Q, T&gt;::value &amp;&amp; !std::is_const&lt;Q&gt;::value &amp;&amp; !std::is_const&lt;T&gt;::value, Q&amp;&gt;::type <a class="el" href="classdatatools_1_1handle.html">datatools::handle</a>&lt; T &gt;::grab </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a non-const reference to the hosted instance. </p>

</div>
</div>
<a id="a19dd12122dedfc2bafdb7c50c283ec4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19dd12122dedfc2bafdb7c50c283ec4e">&#9670;&nbsp;</a></span>has_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdatatools_1_1handle.html">datatools::handle</a>&lt; T &gt;::has_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the internal shared pointer holds something. </p>

</div>
</div>
<a id="a08b333dd6309b1389acb6d3c6c604881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b333dd6309b1389acb6d3c6c604881">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdatatools_1_1handle.html">datatools::handle</a>&lt; T &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the internal shared pointer holds something. </p>

</div>
</div>
<a id="a3c79b193efb3f1e434e355fec0772bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c79b193efb3f1e434e355fec0772bc5">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdatatools_1_1handle.html">datatools::handle</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>elem</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the internal shared pointer with a new instance. </p>

</div>
</div>
<a id="a6862b0b7da8dec2bd40426944ba04212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6862b0b7da8dec2bd40426944ba04212">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classdatatools_1_1handle.html">datatools::handle</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdatatools_1_1handle.html">handle</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a98421be32960e88d3c97631eeced9c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98421be32960e88d3c97631eeced9c59">&#9670;&nbsp;</a></span>to_const()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Q  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt;Q, T&gt;::value &amp;&amp; !std::is_const&lt;Q&gt;::value &amp;&amp; !std::is_const&lt;T&gt;::value, <a class="el" href="classdatatools_1_1handle.html">handle</a>&lt;<a class="el" href="namespacedatatools.html#a8a63304aa8648ed4de282e39ea77e58f">const</a> Q&gt; &gt;::type <a class="el" href="classdatatools_1_1handle.html">datatools::handle</a>&lt; T &gt;::to_const </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a handle instance that hosts the const instance. </p>

</div>
</div>
<a id="a3ae954b63fafda6dcaa4f4928fbf78d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae954b63fafda6dcaa4f4928fbf78d2">&#9670;&nbsp;</a></span>unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdatatools_1_1handle.html">datatools::handle</a>&lt; T &gt;::unique </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the current handle holds an uniquely referenced object. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ac98d07dd8f7b70e16ccb9a01abf56b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98d07dd8f7b70e16ccb9a01abf56b9c">&#9670;&nbsp;</a></span>boost::serialization::access</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class boost::serialization::access</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>bayeux/datatools/<a class="el" href="handle_8h_source.html">handle.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
