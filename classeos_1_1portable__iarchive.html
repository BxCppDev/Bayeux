<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bayeux: eos::portable_iarchive Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_bayeux_66x55_transparent.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Bayeux
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">Core Foundation library for SuperNEMO</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceeos.html">eos</a></li><li class="navelem"><a class="el" href="classeos_1_1portable__iarchive.html">portable_iarchive</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classeos_1_1portable__iarchive-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">eos::portable_iarchive Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Portable binary input archive using little endian format.  
 <a href="classeos_1_1portable__iarchive.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="portable__iarchive_8hpp_source.html">bayeux/datatools/eos/portable_iarchive.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for eos::portable_iarchive:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classeos_1_1portable__iarchive.png" usemap="#eos::portable_5Fiarchive_map" alt=""/>
  <map id="eos::portable_5Fiarchive_map" name="eos::portable_5Fiarchive_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a61fe6428b7fa845c152bfd1c45c9665e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeos_1_1portable__iarchive.html#a61fe6428b7fa845c152bfd1c45c9665e">portable_iarchive</a> (std::istream &amp;is, unsigned flags=0)</td></tr>
<tr class="memdesc:a61fe6428b7fa845c152bfd1c45c9665e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor on a stream using ios::binary mode!  <a href="#a61fe6428b7fa845c152bfd1c45c9665e">More...</a><br /></td></tr>
<tr class="separator:a61fe6428b7fa845c152bfd1c45c9665e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c195d4ab890e7ecfc7d72719b1abff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeos_1_1portable__iarchive.html#ac0c195d4ab890e7ecfc7d72719b1abff">load</a> (std::string &amp;s)</td></tr>
<tr class="memdesc:ac0c195d4ab890e7ecfc7d72719b1abff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load narrow strings.  <a href="#ac0c195d4ab890e7ecfc7d72719b1abff">More...</a><br /></td></tr>
<tr class="separator:ac0c195d4ab890e7ecfc7d72719b1abff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200055573ddc1b1eff27028d5efc6a50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeos_1_1portable__iarchive.html#a200055573ddc1b1eff27028d5efc6a50">load</a> (std::wstring &amp;s)</td></tr>
<tr class="memdesc:a200055573ddc1b1eff27028d5efc6a50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load wide strings.  <a href="#a200055573ddc1b1eff27028d5efc6a50">More...</a><br /></td></tr>
<tr class="separator:a200055573ddc1b1eff27028d5efc6a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4067389ec38e5b69c49dbd2314c07085"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeos_1_1portable__iarchive.html#a4067389ec38e5b69c49dbd2314c07085">load</a> (bool &amp;b)</td></tr>
<tr class="memdesc:a4067389ec38e5b69c49dbd2314c07085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading bool type.  <a href="#a4067389ec38e5b69c49dbd2314c07085">More...</a><br /></td></tr>
<tr class="separator:a4067389ec38e5b69c49dbd2314c07085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a8d09c896094b29de77b1ea419d399"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae4a8d09c896094b29de77b1ea419d399"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if&lt; boost::is_integral&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classeos_1_1portable__iarchive.html#ae4a8d09c896094b29de77b1ea419d399">load</a> (T &amp;t, dummy&lt; 2 &gt;=0)</td></tr>
<tr class="memdesc:ae4a8d09c896094b29de77b1ea419d399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load integer types.  <a href="#ae4a8d09c896094b29de77b1ea419d399">More...</a><br /></td></tr>
<tr class="separator:ae4a8d09c896094b29de77b1ea419d399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc32b4f86f4fcba5c0481ada47f4505"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2cc32b4f86f4fcba5c0481ada47f4505"><td class="memTemplItemLeft" align="right" valign="top">boost::enable_if&lt; boost::is_floating_point&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classeos_1_1portable__iarchive.html#a2cc32b4f86f4fcba5c0481ada47f4505">load</a> (T &amp;t, dummy&lt; 3 &gt;=0)</td></tr>
<tr class="memdesc:a2cc32b4f86f4fcba5c0481ada47f4505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load floating point types.  <a href="#a2cc32b4f86f4fcba5c0481ada47f4505">More...</a><br /></td></tr>
<tr class="separator:a2cc32b4f86f4fcba5c0481ada47f4505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570dd9f5d56b5fb741753d58fee77195"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a570dd9f5d56b5fb741753d58fee77195"><td class="memTemplItemLeft" align="right" valign="top">boost::disable_if&lt; boost::is_arithmetic&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classeos_1_1portable__iarchive.html#a570dd9f5d56b5fb741753d58fee77195">load</a> (T &amp;t, dummy&lt; 4 &gt;=0)</td></tr>
<tr class="separator:a570dd9f5d56b5fb741753d58fee77195"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a80e8142015e4de3d31409eb708ec841c"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeos_1_1portable__iarchive.html#a80e8142015e4de3d31409eb708ec841c">boost::archive::basic_binary_iarchive&lt; portable_iarchive &gt;</a></td></tr>
<tr class="separator:a80e8142015e4de3d31409eb708ec841c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Portable binary input archive using little endian format. </p>
<p>This archive addresses integer size, endianness and floating point types so that data can be transferred across different systems. There may still be constraints as to what systems are compatible and the user will have to take care that e.g. a very large int being saved on a 64 bit machine will result in a <a class="el" href="classeos_1_1portable__archive__exception.html" title="Exception being thrown when serialization cannot proceed. ">portable_archive_exception</a> if loaded into an int on a 32 bit system. A possible workaround to this would be to use fixed types like boost::uint64_t in your serialization structures.</p>
<dl class="section note"><dt>Note</dt><dd>The class is based on the portable binary example by Robert Ramey and uses Beman Dawes endian library plus fp_utilities by Johan Rade. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a61fe6428b7fa845c152bfd1c45c9665e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61fe6428b7fa845c152bfd1c45c9665e">&#9670;&nbsp;</a></span>portable_iarchive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">eos::portable_iarchive::portable_iarchive </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor on a stream using ios::binary mode! </p>
<p>We cannot call basic_binary_iprimitive::init which tries to detect if the binary archive stems from a different platform by examining type sizes.</p>
<p>We could have called basic_binary_iarchive::init which would create the <a class="el" href="namespaceboost_1_1serialization.html" title="Nested namespace of the Boost/Serialization library. ">boost::serialization</a> standard archive header containing also the library version. Due to efficiency we stick with our own. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac0c195d4ab890e7ecfc7d72719b1abff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c195d4ab890e7ecfc7d72719b1abff">&#9670;&nbsp;</a></span>load() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void eos::portable_iarchive::load </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load narrow strings. </p>

</div>
</div>
<a id="a200055573ddc1b1eff27028d5efc6a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a200055573ddc1b1eff27028d5efc6a50">&#9670;&nbsp;</a></span>load() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void eos::portable_iarchive::load </td>
          <td>(</td>
          <td class="paramtype">std::wstring &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load wide strings. </p>
<p>This is rather tricky to get right for true portability as there are so many different character encodings around. However, wide strings that are encoded in one of the Unicode schemes only need to be <em>transcoded</em> which is a lot easier actually.</p>
<p>We generate the output string to be encoded in the system's native format, ie. UTF-16 on Windows and UTF-32 on Linux machines. Don't know about Mac here so I can't really say about that. </p>

</div>
</div>
<a id="a4067389ec38e5b69c49dbd2314c07085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4067389ec38e5b69c49dbd2314c07085">&#9670;&nbsp;</a></span>load() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void eos::portable_iarchive::load </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading bool type. </p>
<p>Byte pattern is same as with integer types, so this function is somewhat redundant but treating bool as integer generates a lot of compiler warnings.</p>
<dl class="section note"><dt>Note</dt><dd>If you cannot compile your application and it says something about load(bool) cannot convert your type A&amp; into bool&amp; then you should check your BOOST_CLASS_IMPLEMENTATION setting for A, as portable_archive is not able to handle custom primitive types in a general manner. </dd></dl>

</div>
</div>
<a id="ae4a8d09c896094b29de77b1ea419d399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a8d09c896094b29de77b1ea419d399">&#9670;&nbsp;</a></span>load() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if&lt;boost::is_integral&lt;T&gt; &gt;::type eos::portable_iarchive::load </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dummy&lt; 2 &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load integer types. </p>
<p>First we load the size information ie. the number of bytes that hold the actual data. Then we retrieve the data and transform it to the original value by using load_little_endian. </p>

</div>
</div>
<a id="a2cc32b4f86f4fcba5c0481ada47f4505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc32b4f86f4fcba5c0481ada47f4505">&#9670;&nbsp;</a></span>load() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::enable_if&lt;boost::is_floating_point&lt;T&gt; &gt;::type eos::portable_iarchive::load </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dummy&lt; 3 &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load floating point types. </p>
<p>We simply rely on fp_traits to set the bit pattern from the (unsigned) integral type that was stored in the stream. Francois Mauger provided standardized behaviour for special values like inf and NaN, that need to be serialized in his application.</p>
<dl class="section note"><dt>Note</dt><dd>by Johan Rade (author of the floating point utilities library): Be warned that the math::detail::fp_traits&lt;T&gt;::type::get_bits() function is <em>not</em> guaranteed to give you all bits of the floating point number. It will give you all bits if and only if there is an integer type that has the same size as the floating point you are copying from. It will not give you all bits for double if there is no uint64_t. It will not give you all bits for long double if sizeof(long double) &gt; 8 or there is no uint64_t.</dd></dl>
<p>The member fp_traits&lt;T&gt;::type::coverage will tell you whether all bits are copied. This is a typedef for either math::detail::all_bits or math::detail::not_all_bits.</p>
<p>If the function does not copy all bits, then it will copy the most significant bits. So if you serialize and deserialize the way you describe, and fp_traits&lt;T&gt;::type::coverage is math::detail::not_all_bits, then your floating point numbers will be truncated. This will introduce small rounding off errors. </p>

</div>
</div>
<a id="a570dd9f5d56b5fb741753d58fee77195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a570dd9f5d56b5fb741753d58fee77195">&#9670;&nbsp;</a></span>load() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::disable_if&lt;boost::is_arithmetic&lt;T&gt; &gt;::type eos::portable_iarchive::load </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dummy&lt; 4 &gt;&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a80e8142015e4de3d31409eb708ec841c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e8142015e4de3d31409eb708ec841c">&#9670;&nbsp;</a></span>boost::archive::basic_binary_iarchive< portable_iarchive ></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class boost::archive::basic_binary_iarchive&lt; <a class="el" href="classeos_1_1portable__iarchive.html">portable_iarchive</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>bayeux/datatools/eos/<a class="el" href="portable__iarchive_8hpp_source.html">portable_iarchive.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
